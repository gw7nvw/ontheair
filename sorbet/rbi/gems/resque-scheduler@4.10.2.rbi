# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `resque-scheduler` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Resque
  include(::Resque::Helpers)
  extend(::Resque::Helpers)
  extend(::Resque)
  extend(::Forwardable)
  extend(::Resque::Scheduler::SchedulingExtensions)
  extend(::Resque::Scheduler::DelayingExtensions)
  extend(::Resque::Scheduler::Extension)

  def after_fork(&block); end
  def after_fork=(block); end
  def after_pause(&block); end
  def after_pause=(block); end
  def before_first_fork(&block); end
  def before_first_fork=(block); end
  def before_fork(&block); end
  def before_fork=(block); end
  def before_pause(&block); end
  def before_pause=(block); end
  def classify(dashed_word); end
  def constantize(camel_cased_word); end
  def data_store; end
  def decode(object); end
  def dequeue(klass, *args); end
  def encode(object); end
  def enqueue(klass, *args); end
  def enqueue_front; end
  def enqueue_front=(_); end
  def enqueue_to(queue, klass, *args); end
  def heartbeat_interval; end
  def heartbeat_interval=(_); end
  def info; end
  def inline; end
  def inline=(_); end
  def inline?; end
  def keys; end
  def list_range(key, start = T.unsafe(nil), count = T.unsafe(nil)); end
  def logger; end
  def logger=(_); end
  def peek(queue, start = T.unsafe(nil), count = T.unsafe(nil)); end
  def pop(queue); end
  def prune_interval; end
  def prune_interval=(_); end
  def push(queue, item); end
  def queue_empty(&block); end
  def queue_empty=(block); end
  def queue_from_class(klass); end
  def queue_sizes; end
  def queues; end
  def redis; end
  def redis=(server); end
  def redis_id; end
  def remove_queue(queue); end
  def remove_worker(worker_id); end
  def reserve(queue); end
  def sample_queues(sample_size = T.unsafe(nil)); end
  def size(queue); end
  def stat_data_store; end
  def stat_data_store=(stat_data_store); end
  def to_s; end
  def validate(klass, queue = T.unsafe(nil)); end
  def watch_queue(queue); end
  def worker_exit(&block); end
  def worker_exit=(block); end
  def workers; end
  def working; end

  private

  def clear_hooks(name); end
  def hooks(name); end
  def register_hook(name, block); end
end

Resque::DEFAULT_HEARTBEAT_INTERVAL = T.let(T.unsafe(nil), Fixnum)

Resque::DEFAULT_PRUNE_INTERVAL = T.let(T.unsafe(nil), Fixnum)

module Resque::Scheduler
  extend(::Resque::Scheduler::Locking)
  extend(::Resque::Scheduler::Configuration)
  extend(::Resque::Scheduler::SignalHandling)

  class << self
    def before_shutdown; end
    def clear_schedule!; end
    def enqueue(config); end
    def enqueue_delayed_items_for_timestamp(timestamp); end
    def enqueue_from_config(job_config); end
    def enqueue_items_in_batch_for_timestamp(timestamp, batch_size); end
    def enqueue_next_item(timestamp); end
    def env_matches?(configured_env); end
    def failure_handler; end
    def failure_handler=(_); end
    def handle_delayed_items(at_time = T.unsafe(nil)); end
    def handle_shutdown; end
    def handle_signals_with_operation; end
    def load_schedule!; end
    def load_schedule_job(name, config); end
    def log(msg); end
    def log!(msg); end
    def log_error(msg); end
    def logger; end
    def logger=(_); end
    def optionizate_interval_value(value); end
    def poll_sleep; end
    def poll_sleep_loop; end
    def print_schedule; end
    def procline(string); end
    def rails_env_matches?(config); end
    def reload_schedule!; end
    def rufus_scheduler; end
    def run; end
    def scheduled_jobs; end
    def shutdown; end
    def stop_rufus_scheduler; end
    def timestamp_key(timestamp); end
    def unschedule_job(name); end
    def update_schedule; end

    private

    def am_master; end
    def app_str; end
    def build_procline(string); end
    def enqueue_recurring(name, config); end
    def env_str; end
    def internal_name; end
  end
end

class Resque::Scheduler::Cli
  def initialize(argv = T.unsafe(nil), env = T.unsafe(nil)); end

  def parse_options; end
  def pre_run; end
  def pre_setup; end
  def run!; end
  def run_forever; end
  def setup_env; end

  private

  def argv; end
  def env; end
  def option_parser; end
  def options; end
  def runtime_env; end

  class << self
    def run!(argv = T.unsafe(nil), env = T.unsafe(nil)); end
  end
end

Resque::Scheduler::Cli::BANNER = T.let(T.unsafe(nil), String)

Resque::Scheduler::Cli::OPTIONS = T.let(T.unsafe(nil), Array)

module Resque::Scheduler::Configuration
  def app_name; end
  def app_name=(_); end
  def configure; end
  def delayed_requeue_batch_size; end
  def dynamic; end
  def dynamic=(_); end
  def env; end
  def env=(_); end
  def environment; end
  def environment=(_); end
  def logfile; end
  def logfile=(_); end
  def logformat; end
  def logformat=(_); end
  def poll_sleep_amount; end
  def poll_sleep_amount=(_); end
  def quiet; end
  def quiet=(_); end
  def verbose; end
  def verbose=(_); end

  private

  def to_bool(value); end
end

Resque::Scheduler::Configuration::TRUE_VALUES = T.let(T.unsafe(nil), Set)

module Resque::Scheduler::DelayingExtensions
  def clean_up_timestamp(key, timestamp); end
  def count_all_scheduled_jobs; end
  def delay_or_enqueue_at(timestamp, klass, *args); end
  def delay_or_enqueue_in(number_of_seconds_from_now, klass, *args); end
  def delayed?(klass, *args); end
  def delayed_push(timestamp, item); end
  def delayed_queue_peek(start, count); end
  def delayed_queue_schedule_size; end
  def delayed_timestamp_peek(timestamp, start, count); end
  def delayed_timestamp_size(timestamp); end
  def enqueue_at(timestamp, klass, *args); end
  def enqueue_at_with_queue(queue, timestamp, klass, *args); end
  def enqueue_delayed(klass, *args); end
  def enqueue_delayed_selection(klass = T.unsafe(nil)); end
  def enqueue_delayed_with_queue(klass, queue, *args); end
  def enqueue_in(number_of_seconds_from_now, klass, *args); end
  def enqueue_in_with_queue(queue, number_of_seconds_from_now, klass, *args); end
  def find_delayed_selection(klass = T.unsafe(nil), &block); end
  def get_last_enqueued_at(job_name); end
  def last_enqueued_at(job_name, date); end
  def next_delayed_timestamp(at_time = T.unsafe(nil)); end
  def next_item_for_timestamp(timestamp); end
  def remove_delayed(klass, *args); end
  def remove_delayed_in_queue(klass, queue, *args); end
  def remove_delayed_job_from_timestamp(timestamp, klass, *args); end
  def remove_delayed_selection(klass = T.unsafe(nil)); end
  def reset_delayed_queue; end
  def scheduled_at(klass, *args); end

  private

  def job_to_hash(klass, args); end
  def job_to_hash_with_queue(queue, klass, args); end
  def payload_matches_selection?(decoded_payload, klass); end
  def plugin; end
  def remove_delayed_job(encoded_job); end
  def search_first_delayed_timestamp_in_range(start_at, stop_at); end
end

module Resque::Scheduler::Extension
  include(::Resque::Scheduler::SchedulingExtensions)
  include(::Resque::Scheduler::DelayingExtensions)
end

class Resque::Scheduler::FailureHandler
  class << self
    def on_enqueue_failure(_, e); end
  end
end

Resque::Scheduler::INTERMITTENT_ERRORS = T.let(T.unsafe(nil), Array)

module Resque::Scheduler::Lock
end

class Resque::Scheduler::Lock::Base
  def initialize(key, options = T.unsafe(nil)); end

  def acquire!; end
  def key; end
  def locked?; end
  def release; end
  def release!; end
  def timeout; end
  def timeout=(_); end
  def value; end

  private

  def extend_lock!; end
  def hostname; end
  def process_id; end
end

class Resque::Scheduler::Lock::Basic < ::Resque::Scheduler::Lock::Base
  def acquire!; end
  def locked?; end
end

class Resque::Scheduler::Lock::Resilient < ::Resque::Scheduler::Lock::Base
  def acquire!; end
  def locked?; end
  def timeout=(seconds); end

  private

  def acquire_sha(refresh = T.unsafe(nil)); end
  def evalsha(script, keys, argv, refresh: T.unsafe(nil)); end
  def locked_sha(refresh = T.unsafe(nil)); end
end

module Resque::Scheduler::Locking
  def master?; end
  def master_lock; end
  def release_master_lock; end
  def release_master_lock!; end
  def supports_lua?; end

  private

  def build_master_lock; end
  def master_lock_key; end
  def redis_master_version; end
end

class Resque::Scheduler::LoggerBuilder
  def initialize(opts = T.unsafe(nil)); end

  def build; end

  private

  def json_formatter; end
  def level; end
  def logfmt_formatter; end
  def text_formatter; end
end

module Resque::Scheduler::Plugin
  class << self
    def hooks(job, pattern); end
    def run_after_schedule_hooks(klass, *args); end
    def run_before_delayed_enqueue_hooks(klass, *args); end
    def run_before_schedule_hooks(klass, *args); end
    def run_hooks(job, pattern, *args); end
  end
end

module Resque::Scheduler::SchedulingExtensions
  def all_schedules; end
  def fetch_schedule(name); end
  def reload_schedule!; end
  def remove_schedule(name, reload = T.unsafe(nil)); end
  def schedule; end
  def schedule=(schedule_hash); end
  def set_schedule(name, config, reload = T.unsafe(nil)); end

  private

  def non_persistent_schedules; end
  def persistent_schedules; end
  def prepare_schedules(schedule_hash); end
end

module Resque::Scheduler::SignalHandling
  def handle_signals; end
  def register_signal_handlers; end
  def signal_queue; end
  def signal_queue=(_); end
end

class Resque::Scheduler::Util
  class << self
    def classify(dashed_word); end
    def constantize(camel_cased_word); end
  end
end

Resque::Scheduler::VERSION = T.let(T.unsafe(nil), String)

Resque::VERSION = T.let(T.unsafe(nil), String)

Resque::Scheduler::CLI_OPTIONS_ENV_MAPPING = T.let(T.unsafe(nil), Hash)

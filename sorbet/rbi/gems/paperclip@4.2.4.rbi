# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `paperclip` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Paperclip
  extend(::Paperclip::Helpers)
  extend(::Paperclip::Logger)
  extend(::Paperclip::ProcessorHelpers)

  class << self
    def io_adapters; end
    def io_adapters=(new_registry); end
    def missing_attachments_styles; end
    def options; end
    def registered_attachments_styles_path; end
    def registered_attachments_styles_path=(_); end
    def save_current_attachments_styles!; end

    private

    def current_attachments_styles; end
    def get_registered_attachments_styles; end
  end
end

class Paperclip::AbstractAdapter
  def assignment?; end
  def binmode(*args, &block); end
  def binmode?(*args, &block); end
  def close(*args, &block); end
  def close!(*args, &block); end
  def closed?(*args, &block); end
  def content_type; end
  def eof?(*args, &block); end
  def fingerprint; end
  def inspect; end
  def nil?; end
  def original_filename; end
  def original_filename=(new_filename); end
  def path(*args, &block); end
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end
  def rewind(*args, &block); end
  def size; end
  def unlink(*args, &block); end

  private

  def copy_to_tempfile(src); end
  def destination; end
end

Paperclip::AbstractAdapter::OS_RESTRICTED_CHARACTERS = T.let(T.unsafe(nil), Regexp)

class Paperclip::AdapterRegistry
  def initialize; end

  def for(target); end
  def handler_for(target); end
  def register(handler_class, &block); end
  def registered?(target); end
  def registered_handlers; end
end

class Paperclip::AdapterRegistry::NoHandlerError < ::Paperclip::Error
end

class Paperclip::Attachment
  def initialize(name, instance, options = T.unsafe(nil)); end

  def as_json(options = T.unsafe(nil)); end
  def assign(uploaded_file); end
  def blank?; end
  def clear(*styles_to_clear); end
  def content_type; end
  def convert_options; end
  def created_at; end
  def default_options; end
  def default_style; end
  def destroy; end
  def dirty?; end
  def errors; end
  def expiring_url(time = T.unsafe(nil), style_name = T.unsafe(nil)); end
  def file?; end
  def fingerprint; end
  def hash_key(style_name = T.unsafe(nil)); end
  def instance; end
  def instance_read(attr); end
  def instance_respond_to?(attr); end
  def instance_write(attr, value); end
  def interpolator; end
  def name; end
  def only_process; end
  def options; end
  def original_filename; end
  def path(style_name = T.unsafe(nil)); end
  def post_processing; end
  def post_processing=(_); end
  def present?; end
  def processors; end
  def queued_for_write; end
  def reprocess!(*style_args); end
  def save; end
  def size; end
  def source_file_options; end
  def staged?; end
  def staged_path(style_name = T.unsafe(nil)); end
  def styles; end
  def time_zone; end
  def to_s(style_name = T.unsafe(nil)); end
  def updated_at; end
  def uploaded_file; end
  def url(style_name = T.unsafe(nil), options = T.unsafe(nil)); end
  def whiny; end

  private

  def able_to_store_created_at?; end
  def active_validator_classes; end
  def after_flush_writes; end
  def assign_attributes; end
  def assign_file_information; end
  def assign_fingerprint(fingerprint); end
  def assign_timestamps; end
  def cleanup_filename(filename); end
  def dirty!; end
  def ensure_required_accessors!; end
  def ensure_required_validations!; end
  def extra_options_for(style); end
  def extra_source_file_options_for(style); end
  def filename_cleaner; end
  def flush_errors; end
  def has_enabled_but_unset_created_at?; end
  def initialize_storage; end
  def interpolate(pattern, style_name = T.unsafe(nil)); end
  def log(message); end
  def missing_required_validator?; end
  def path_option; end
  def post_process(*style_args); end
  def post_process_file; end
  def post_process_style(name, style); end
  def post_process_styles(*style_args); end
  def process_options(options_type, style); end
  def process_style?(style_name, style_args); end
  def queue_all_for_delete; end
  def queue_some_for_delete(*styles); end
  def reset_file_if_original_reprocessed; end
  def reset_updater; end
  def unlink_files(files); end
  def updater; end

  class << self
    def default_options; end
  end
end

class Paperclip::AttachmentAdapter < ::Paperclip::AbstractAdapter
  def initialize(target); end


  private

  def cache_current_values; end
  def copy_to_tempfile(source); end
end

class Paperclip::AttachmentRegistry
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def initialize; end

  def clear; end
  def definitions_for(klass); end
  def each_definition; end
  def names_for(klass); end
  def register(klass, attachment_name, attachment_options); end

  class << self
    def clear; end
    def definitions_for(klass); end
    def each_definition(&block); end
    def instance; end
    def names_for(klass); end
    def register(klass, attachment_name, attachment_options); end
  end
end

module Paperclip::Callbacks
  include(::Paperclip::Callbacks::Running)

  mixes_in_class_methods(::Paperclip::Callbacks::Defining)

  class << self
    def included(base); end
  end
end

module Paperclip::Callbacks::Defining
  def define_paperclip_callbacks(*callbacks); end

  private

  def callback_terminator; end
end

module Paperclip::Callbacks::Running
  def run_paperclip_callbacks(callback, &block); end
end

module Paperclip::ClassMethods
  def has_attached_file(name, options = T.unsafe(nil)); end
end

class Paperclip::ContentTypeDetector
  def initialize(filename); end

  def detect; end

  private

  def blank_name?; end
  def calculated_type_matches; end
  def empty?; end
  def empty_file?; end
  def possible_types; end
  def type_from_file_command; end
end

Paperclip::ContentTypeDetector::EMPTY_TYPE = T.let(T.unsafe(nil), String)

Paperclip::ContentTypeDetector::SENSIBLE_DEFAULT = T.let(T.unsafe(nil), String)

class Paperclip::DataUriAdapter < ::Paperclip::StringioAdapter
  def initialize(target_uri); end


  private

  def extract_target(uri); end
end

Paperclip::DataUriAdapter::REGEXP = T.let(T.unsafe(nil), Regexp)

class Paperclip::EmptyStringAdapter < ::Paperclip::AbstractAdapter
  def initialize(target); end

  def assignment?; end
  def nil?; end
end

class Paperclip::Error < ::StandardError
end

module Paperclip::Errors
end

class Paperclip::Errors::CommandNotFoundError < ::Paperclip::Error
end

class Paperclip::Errors::InfiniteInterpolationError < ::Paperclip::Error
end

class Paperclip::Errors::MissingRequiredValidatorError < ::Paperclip::Error
end

class Paperclip::Errors::NotIdentifiedByImageMagickError < ::Paperclip::Error
end

class Paperclip::Errors::StorageMethodNotFound < ::Paperclip::Error
end

class Paperclip::FileAdapter < ::Paperclip::AbstractAdapter
  def initialize(target); end


  private

  def cache_current_values; end
end

class Paperclip::FileCommandContentTypeDetector
  def initialize(filename); end

  def detect; end

  private

  def type_from_file_command; end
end

Paperclip::FileCommandContentTypeDetector::SENSIBLE_DEFAULT = T.let(T.unsafe(nil), String)

class Paperclip::FilenameCleaner
  def initialize(invalid_character_regex); end

  def call(filename); end
end

class Paperclip::Geometry
  def initialize(width = T.unsafe(nil), height = T.unsafe(nil), modifier = T.unsafe(nil)); end

  def aspect; end
  def auto_orient; end
  def height; end
  def height=(_); end
  def horizontal?; end
  def inspect; end
  def larger; end
  def modifier; end
  def modifier=(_); end
  def resize_to(geometry); end
  def smaller; end
  def square?; end
  def to_s; end
  def transformation_to(dst, crop = T.unsafe(nil)); end
  def vertical?; end
  def width; end
  def width=(_); end

  private

  def cropping(dst, ratio, scale); end
  def scale_to(new_geometry); end
  def scaling(dst, ratio); end

  class << self
    def from_file(file); end
    def parse(string); end
  end
end

Paperclip::Geometry::EXIF_ROTATED_ORIENTATION_VALUES = T.let(T.unsafe(nil), Array)

class Paperclip::GeometryDetector
  def initialize(file); end

  def make; end

  private

  def geometry_string; end
  def path; end
  def raise_because_imagemagick_missing; end
  def raise_if_blank_file; end
end

class Paperclip::GeometryParser
  def initialize(string); end

  def make; end

  private

  def match; end
end

Paperclip::GeometryParser::FORMAT = T.let(T.unsafe(nil), Regexp)

module Paperclip::Glue
  include(::Paperclip::Callbacks::Running)
  include(::Paperclip::Callbacks)
  include(::Paperclip::Validators::HelperMethods)
  include(::Paperclip::Validators)
  include(::Paperclip::Schema)

  mixes_in_class_methods(::Paperclip::ClassMethods)

  class << self
    def included(base); end
  end
end

class Paperclip::HasAttachedFile
  def initialize(klass, name, options); end

  def define; end

  private

  def add_active_record_callbacks; end
  def add_paperclip_callbacks; end
  def add_required_validations; end
  def define_class_getter; end
  def define_flush_errors; end
  def define_getters; end
  def define_instance_getter; end
  def define_query; end
  def define_setter; end
  def register_new_attachment; end

  class << self
    def define_on(klass, name, options); end
  end
end

module Paperclip::HasAttachedFile::ClassMethods
  def attachment_definitions; end
end

module Paperclip::Helpers
  def class_for(class_name); end
  def configure; end
  def each_instance_with_attachment(klass, name); end
  def interpolates(key, &block); end
  def reset_duplicate_clash_check!; end
  def run(cmd, arguments = T.unsafe(nil), interpolation_values = T.unsafe(nil), local_options = T.unsafe(nil)); end
end

class Paperclip::HttpUrlProxyAdapter < ::Paperclip::UriAdapter
  def initialize(target); end
end

Paperclip::HttpUrlProxyAdapter::REGEXP = T.let(T.unsafe(nil), Regexp)

class Paperclip::IdentityAdapter < ::Paperclip::AbstractAdapter
  def new(adapter); end
end

module Paperclip::Interpolations
  extend(::Paperclip::Interpolations)

  def attachment(attachment, style_name); end
  def basename(attachment, style_name); end
  def class(attachment = T.unsafe(nil), style_name = T.unsafe(nil)); end
  def content_type_extension(attachment, style_name); end
  def dotextension(attachment, style_name); end
  def extension(attachment, style_name); end
  def filename(attachment, style_name); end
  def fingerprint(attachment, style_name); end
  def hash(attachment = T.unsafe(nil), style_name = T.unsafe(nil)); end
  def id(attachment, style_name); end
  def id_partition(attachment, style_name); end
  def param(attachment, style_name); end
  def rails_env(attachment, style_name); end
  def rails_root(attachment, style_name); end
  def style(attachment, style_name); end
  def timestamp(attachment, style_name); end
  def updated_at(attachment, style_name); end
  def url(attachment, style_name); end

  class << self
    def [](name); end
    def []=(name, block); end
    def all; end
    def interpolate(pattern, *args); end
    def plural_cache; end
  end
end

class Paperclip::Interpolations::PluralCache
  def initialize; end

  def pluralize(word); end
  def underscore_and_pluralize(word); end
end

Paperclip::Interpolations::RIGHT_HERE = T.let(T.unsafe(nil), String)

module Paperclip::Logger
  def log(message); end
  def logger; end
  def logger=(logger); end
  def logging?; end
end

class Paperclip::MediaTypeSpoofDetector
  def initialize(file, name, content_type); end

  def spoofed?; end

  private

  def calculated_content_type; end
  def calculated_media_type; end
  def calculated_type_mismatch?; end
  def content_types_from_name; end
  def filename_extension; end
  def has_extension?; end
  def has_name?; end
  def mapped_content_type; end
  def mapping_override_mismatch?; end
  def media_type_mismatch?; end
  def media_types_from_name; end
  def supplied_content_type; end
  def supplied_media_type; end
  def supplied_type_mismatch?; end
  def type_from_file_command; end

  class << self
    def using(file, name, content_type); end
  end
end

class Paperclip::NilAdapter < ::Paperclip::AbstractAdapter
  def initialize(target); end

  def content_type; end
  def eof?; end
  def nil?; end
  def original_filename; end
  def read(*args); end
  def size; end
end

class Paperclip::Processor
  def initialize(file, options = T.unsafe(nil), attachment = T.unsafe(nil)); end

  def attachment; end
  def attachment=(_); end
  def convert(arguments = T.unsafe(nil), local_options = T.unsafe(nil)); end
  def file; end
  def file=(_); end
  def identify(arguments = T.unsafe(nil), local_options = T.unsafe(nil)); end
  def make; end
  def options; end
  def options=(_); end

  class << self
    def make(file, options = T.unsafe(nil), attachment = T.unsafe(nil)); end
  end
end

module Paperclip::ProcessorHelpers
  def clear_processors!; end
  def load_processor(name); end
  def processor(name); end
  def register_processor(name, processor); end
end

class Paperclip::ProcessorHelpers::NoSuchProcessor < ::StandardError
end

Paperclip::REQUIRED_VALIDATORS = T.let(T.unsafe(nil), Array)

class Paperclip::Railtie < ::Rails::Railtie
  class << self
    def insert; end
  end
end

module Paperclip::Schema
  class << self
    def included(base); end
  end
end

Paperclip::Schema::COLUMNS = T.let(T.unsafe(nil), Hash)

module Paperclip::Schema::CommandRecorder
  def add_attachment(*args); end

  private

  def invert_add_attachment(args); end
end

module Paperclip::Schema::Statements
  def add_attachment(table_name, *attachment_names); end
  def drop_attached_file(*args); end
  def remove_attachment(table_name, *attachment_names); end
end

module Paperclip::Schema::TableDefinition
  def attachment(*attachment_names); end
  def has_attached_file(*attachment_names); end
end

module Paperclip::Storage
end

module Paperclip::Storage::Filesystem
  def copy_to_local_file(style, local_dest_path); end
  def exists?(style_name = T.unsafe(nil)); end
  def flush_deletes; end
  def flush_writes; end

  class << self
    def extended(base); end
  end
end

module Paperclip::Storage::Fog
  def copy_to_local_file(style, local_dest_path); end
  def exists?(style = T.unsafe(nil)); end
  def expiring_url(time = T.unsafe(nil), style_name = T.unsafe(nil)); end
  def flush_deletes; end
  def flush_writes; end
  def fog_credentials; end
  def fog_file; end
  def fog_public(style = T.unsafe(nil)); end
  def parse_credentials(creds); end
  def public_url(style = T.unsafe(nil)); end

  private

  def connection; end
  def convert_time(time); end
  def directory; end
  def dynamic_fog_host_for_style(style); end
  def find_credentials(creds); end
  def host_name_for_directory; end
  def scheme; end

  class << self
    def extended(base); end
  end
end

Paperclip::Storage::Fog::AWS_BUCKET_SUBDOMAIN_RESTRICTON_REGEX = T.let(T.unsafe(nil), Regexp)

module Paperclip::Storage::S3
  def bucket_name; end
  def copy_to_local_file(style, local_dest_path); end
  def create_bucket; end
  def exists?(style = T.unsafe(nil)); end
  def expiring_url(time = T.unsafe(nil), style_name = T.unsafe(nil)); end
  def flush_deletes; end
  def flush_writes; end
  def http_proxy_host; end
  def http_proxy_password; end
  def http_proxy_port; end
  def http_proxy_user; end
  def obtain_s3_instance_for(options); end
  def parse_credentials(creds); end
  def s3_bucket; end
  def s3_credentials; end
  def s3_host_alias; end
  def s3_host_name; end
  def s3_interface; end
  def s3_object(style_name = T.unsafe(nil)); end
  def s3_permissions(style = T.unsafe(nil)); end
  def s3_protocol(style = T.unsafe(nil), with_colon = T.unsafe(nil)); end
  def s3_storage_class(style = T.unsafe(nil)); end
  def s3_url_options; end
  def set_permissions(permissions); end
  def set_storage_class(storage_class); end
  def using_http_proxy?; end

  private

  def find_credentials(creds); end
  def merge_s3_headers(http_headers, s3_headers, s3_metadata); end
  def use_secure_protocol?(style_name); end

  class << self
    def extended(base); end
  end
end

class Paperclip::StringioAdapter < ::Paperclip::AbstractAdapter
  def initialize(target); end

  def content_type=(_); end

  private

  def cache_current_values; end
  def copy_to_tempfile(source); end
end

class Paperclip::Style
  def initialize(name, definition, attachment); end

  def [](key); end
  def []=(key, value); end
  def attachment; end
  def convert_options; end
  def default_format; end
  def format; end
  def geometry; end
  def name; end
  def processor_options; end
  def processors; end
  def source_file_options; end
  def whiny; end
  def whiny?; end
end

class Paperclip::Tempfile < ::Tempfile
  def make_tmpname(prefix_suffix, n); end
end

module Paperclip::TempfileEncoding
  def binmode; end
end

class Paperclip::TempfileFactory
  def basename; end
  def extension; end
  def generate(name = T.unsafe(nil)); end
  def random_name; end
end

class Paperclip::Thumbnail < ::Paperclip::Processor
  def initialize(file, options = T.unsafe(nil), attachment = T.unsafe(nil)); end

  def animated; end
  def animated=(_); end
  def auto_orient; end
  def auto_orient=(_); end
  def convert_options; end
  def convert_options=(_); end
  def convert_options?; end
  def crop?; end
  def current_geometry; end
  def current_geometry=(_); end
  def format; end
  def format=(_); end
  def make; end
  def source_file_options; end
  def source_file_options=(_); end
  def target_geometry; end
  def target_geometry=(_); end
  def transformation_command; end
  def whiny; end
  def whiny=(_); end

  protected

  def animated?; end
  def identified_as_animated?; end
end

Paperclip::Thumbnail::ANIMATED_FORMATS = T.let(T.unsafe(nil), Array)

class Paperclip::UploadedFileAdapter < ::Paperclip::AbstractAdapter
  def initialize(target); end


  private

  def cache_current_values; end
  def content_type_detector; end
  def determine_content_type; end

  class << self
    def content_type_detector; end
    def content_type_detector=(_); end
  end
end

class Paperclip::UriAdapter < ::Paperclip::AbstractAdapter
  def initialize(target); end

  def content_type=(_); end

  private

  def cache_current_values; end
  def copy_to_tempfile(src); end
  def download_content; end
end

class Paperclip::UrlGenerator
  def initialize(attachment, attachment_options); end

  def for(style_name, options); end

  private

  def default_url; end
  def escape_regex; end
  def escape_url(url); end
  def escape_url_as_needed(url, options); end
  def most_appropriate_url; end
  def timestamp_as_needed(url, options); end
  def timestamp_possible?; end
end

Paperclip::VERSION = T.let(T.unsafe(nil), String)

module Paperclip::Validators
  extend(::ActiveSupport::Concern)

  include(::Paperclip::Validators::HelperMethods)

  mixes_in_class_methods(::Paperclip::Validators::HelperMethods)
end

class Paperclip::Validators::AttachmentContentTypeValidator < ::ActiveModel::EachValidator
  def initialize(options); end

  def allowed_types; end
  def check_validity!; end
  def forbidden_types; end
  def mark_invalid(record, attribute, types); end
  def validate_blacklist(record, attribute, value); end
  def validate_each(record, attribute, value); end
  def validate_whitelist(record, attribute, value); end

  class << self
    def helper_method_name; end
  end
end

class Paperclip::Validators::AttachmentFileNameValidator < ::ActiveModel::EachValidator
  def initialize(options); end

  def allowed; end
  def check_validity!; end
  def forbidden; end
  def mark_invalid(record, attribute, patterns); end
  def validate_blacklist(record, attribute, value); end
  def validate_each(record, attribute, value); end
  def validate_whitelist(record, attribute, value); end

  class << self
    def helper_method_name; end
  end
end

class Paperclip::Validators::AttachmentFileTypeIgnoranceValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end

  class << self
    def helper_method_name; end
  end
end

class Paperclip::Validators::AttachmentPresenceValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end

  class << self
    def helper_method_name; end
  end
end

class Paperclip::Validators::AttachmentSizeValidator < ::ActiveModel::Validations::NumericalityValidator
  def initialize(options); end

  def check_validity!; end
  def validate_each(record, attr_name, value); end

  private

  def extract_option_value(option, option_value); end
  def extract_options(options); end
  def human_size(size); end
  def max_value_in_human_size(record); end
  def min_value_in_human_size(record); end

  class << self
    def helper_method_name; end
  end
end

Paperclip::Validators::AttachmentSizeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

module Paperclip::Validators::ClassMethods
  def create_validating_before_filter(attribute, validator_class, options); end
  def validate_before_processing(validator_class, options); end
  def validates_attachment(*attributes); end
end

module Paperclip::Validators::HelperMethods
  def do_not_validate_attachment_file_type(*attr_names); end
  def validates_attachment_content_type(*attr_names); end
  def validates_attachment_file_name(*attr_names); end
  def validates_attachment_presence(*attr_names); end
  def validates_attachment_size(*attr_names); end
  def validates_media_type_spoof_detection(*attr_names); end
end

class Paperclip::Validators::MediaTypeSpoofDetectionValidator < ::ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
end

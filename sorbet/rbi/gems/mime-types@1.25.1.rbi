# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mime-types` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module MIME
end

class MIME::InvalidContentType < ::RuntimeError
end

class MIME::Type
  include(::Comparable)

  def initialize(content_type); end

  def <=>(other); end
  def ascii?; end
  def binary?; end
  def complete?; end
  def content_type; end
  def default_encoding; end
  def docs; end
  def docs=(d); end
  def encoding; end
  def encoding=(enc); end
  def eql?(other); end
  def extensions; end
  def extensions=(ext); end
  def like?(other); end
  def media_type; end
  def obsolete=(_); end
  def obsolete?; end
  def platform?; end
  def priority_compare(other); end
  def raw_media_type; end
  def raw_sub_type; end
  def registered=(_); end
  def registered?; end
  def signature?; end
  def simplified; end
  def sub_type; end
  def system; end
  def system=(os); end
  def system?; end
  def to_a; end
  def to_hash; end
  def to_s; end
  def to_str; end
  def url; end
  def url=(_); end
  def urls; end
  def use_instead; end

  class << self
    def from_array(*args); end
    def from_hash(hash); end
    def from_mime_type(mime_type); end
    def simplified(content_type); end
  end
end

MIME::Type::CONTACT_URL = T.let(T.unsafe(nil), String)

MIME::Type::DRAFT_URL = T.let(T.unsafe(nil), String)

MIME::Type::ENCODING_RE = T.let(T.unsafe(nil), Regexp)

MIME::Type::IANA_URL = T.let(T.unsafe(nil), String)

MIME::Type::LTSW_URL = T.let(T.unsafe(nil), String)

MIME::Type::MEDIA_TYPE_RE = T.let(T.unsafe(nil), Regexp)

MIME::Type::PLATFORM_RE = T.let(T.unsafe(nil), Regexp)

MIME::Type::RFC_URL = T.let(T.unsafe(nil), String)

MIME::Type::SIGNATURES = T.let(T.unsafe(nil), Array)

MIME::Type::UNREG_RE = T.let(T.unsafe(nil), Regexp)

MIME::Type::VERSION = T.let(T.unsafe(nil), String)

class MIME::Types
  extend(::Enumerable)

  def initialize(data_version = T.unsafe(nil)); end

  def [](type_id, flags = T.unsafe(nil)); end
  def add(*types); end
  def add_type_variant(mime_type); end
  def count; end
  def data_version; end
  def defined_types; end
  def each; end
  def index_extensions(mime_type); end
  def of(filename, platform = T.unsafe(nil)); end
  def type_for(filename, platform = T.unsafe(nil)); end

  private

  def match(pattern); end
  def prune_matches(matches, flags); end

  class << self
    def [](type_id, flags = T.unsafe(nil)); end
    def add(*types); end
    def add_type_variant(mime_type); end
    def cache_file; end
    def count; end
    def each; end
    def index_extensions(mime_type); end
    def load_from_file(filename); end
    def of(filename, platform = T.unsafe(nil)); end
    def type_for(filename, platform = T.unsafe(nil)); end

    private

    def __types__; end
    def lazy_load?; end
    def load_and_parse_mime_types; end
    def load_mime_types; end
    def load_mime_types_from_cache; end
    def load_mime_types_from_cache!; end
    def write_mime_types_to_cache; end
    def write_mime_types_to_cache!; end
  end
end

class MIME::Types::CacheContainer
  def initialize(version, data); end

  def data; end
  def version; end
end

MIME::Types::DATA_VERSION = T.let(T.unsafe(nil), Fixnum)

class MIME::Types::HashWithArrayDefault < ::Hash
  def initialize; end

  def marshal_dump; end
  def marshal_load(hash); end
end

MIME::Types::VERSION = T.let(T.unsafe(nil), String)

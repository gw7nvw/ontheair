# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rgeo` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module RGeo
end

module RGeo::Cartesian
  class << self
    def factory(opts_ = T.unsafe(nil)); end
    def factory_generator(defaults_ = T.unsafe(nil)); end
    def preferred_factory(opts_ = T.unsafe(nil)); end
    def preferred_factory_generator(defaults_ = T.unsafe(nil)); end
    def simple_factory(opts_ = T.unsafe(nil)); end
    def simple_factory_generator(defaults_ = T.unsafe(nil)); end
  end
end

module RGeo::Cartesian::Analysis
  class << self
    def ring_direction(ring_); end
  end
end

class RGeo::Cartesian::BoundingBox
  def initialize(factory_, opts_ = T.unsafe(nil)); end

  def ==(rhs_); end
  def _add_geometry(geometry_); end
  def _add_point(point_); end
  def add(geometry_); end
  def center_m; end
  def center_x; end
  def center_y; end
  def center_z; end
  def contains?(rhs_, opts_ = T.unsafe(nil)); end
  def degenerate?; end
  def empty?; end
  def eql?(rhs_); end
  def factory; end
  def has_m; end
  def has_z; end
  def infinitesimal?; end
  def m_span; end
  def max_m; end
  def max_point; end
  def max_x; end
  def max_y; end
  def max_z; end
  def min_m; end
  def min_point; end
  def min_x; end
  def min_y; end
  def min_z; end
  def subdivide(opts_ = T.unsafe(nil)); end
  def to_geometry; end
  def x_span; end
  def y_span; end
  def z_span; end

  class << self
    def create_from_geometry(geom_, opts_ = T.unsafe(nil)); end
    def create_from_points(point1_, point2_, opts_ = T.unsafe(nil)); end
  end
end

class RGeo::Cartesian::Factory
  include(::RGeo::Feature::Factory::Instance)

  def initialize(opts_ = T.unsafe(nil)); end

  def ==(rhs_); end
  def _generate_wkb(obj_); end
  def _generate_wkt(obj_); end
  def _marshal_wkb_generator; end
  def _marshal_wkb_parser; end
  def _psych_wkt_generator; end
  def _psych_wkt_parser; end
  def collection(elems_); end
  def coord_sys; end
  def encode_with(coder_); end
  def eql?(rhs_); end
  def hash; end
  def init_with(coder_); end
  def line(start_, end_); end
  def line_string(points_); end
  def linear_ring(points_); end
  def marshal_dump; end
  def marshal_load(data_); end
  def multi_line_string(elems_); end
  def multi_point(elems_); end
  def multi_polygon(elems_); end
  def parse_wkb(str_); end
  def parse_wkt(str_); end
  def point(x_, y_, *extra_); end
  def polygon(outer_ring_, inner_rings_ = T.unsafe(nil)); end
  def proj4; end
  def property(name_); end
  def srid; end
end

class RGeo::Cartesian::GeometryCollectionImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Cartesian::GeometryMethods
  def envelope; end
  def srid; end
end

class RGeo::Cartesian::LineImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::Line)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::ImplHelper::BasicLineMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::Cartesian::LineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Cartesian::LineStringImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::Cartesian::LineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Cartesian::LineStringMethods
  def _segments; end
  def is_simple?; end
  def length; end
end

class RGeo::Cartesian::LinearRingImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::LinearRing)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::ImplHelper::BasicLinearRingMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::Cartesian::LineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Cartesian::MultiLineStringImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiCurve)
  include(::RGeo::Feature::MultiLineString)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiLineStringMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::Cartesian::MultiLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Cartesian::MultiLineStringMethods
  def length; end
end

class RGeo::Cartesian::MultiPointImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiPoint)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiPointMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Cartesian::MultiPolygonImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiSurface)
  include(::RGeo::Feature::MultiPolygon)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiPolygonMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Cartesian::PointImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Point)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicPointMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::Cartesian::PointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Cartesian::PointMethods
  def buffer(distance_); end
  def distance(rhs_); end
end

class RGeo::Cartesian::PolygonImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Surface)
  include(::RGeo::Feature::Polygon)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicPolygonMethods)
  include(::RGeo::Cartesian::GeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Cartesian::Segment
  def initialize(start_, end_); end

  def ==(rhs_); end
  def contains_point?(p_); end
  def degenerate?; end
  def dx; end
  def dy; end
  def e; end
  def eql?(rhs_); end
  def intersects_segment?(seg_); end
  def length; end
  def s; end
  def side(p_); end
  def to_s; end
  def tproj(p_); end
end

module RGeo::CoordSys
end

module RGeo::CoordSys::CS
  class << self
    def create_from_wkt(str_); end
  end
end

RGeo::CoordSys::CS::AO_DOWN = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::AO_EAST = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::AO_NORTH = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::AO_OTHER = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::AO_SOUTH = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::AO_UP = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::AO_WEST = T.let(T.unsafe(nil), Fixnum)

class RGeo::CoordSys::CS::AngularUnit < ::RGeo::CoordSys::CS::Unit
  def radians_per_unit; end

  class << self
    def create(name_, radians_per_unit_, *optional_); end
  end
end

class RGeo::CoordSys::CS::AxisInfo < ::RGeo::CoordSys::CS::Base
  def initialize(name_, orientation_); end

  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end
  def name; end
  def orientation; end

  class << self
    def create(name_, orientation_); end
  end
end

RGeo::CoordSys::CS::AxisInfo::NAMES_BY_VALUE = T.let(T.unsafe(nil), Array)

class RGeo::CoordSys::CS::Base
  def ==(rhs_); end
  def _to_wkt(open_, close_); end
  def encode_with(coder_); end
  def eql?(rhs_); end
  def hash; end
  def init_with(coder_); end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data_); end
  def to_s; end
  def to_wkt(opts_ = T.unsafe(nil)); end
end

class RGeo::CoordSys::CS::CompoundCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name_, head_, tail_, *optional_); end

  def _wkt_content(open_, close_); end
  def _wkt_typename; end
  def get_axis(index_); end
  def get_units(index_); end
  def head; end
  def tail; end

  class << self
    def create(name_, head_, tail_, *optional_); end
  end
end

class RGeo::CoordSys::CS::CoordinateSystem < ::RGeo::CoordSys::CS::Info
  def initialize(name_, dimension_, *optional_); end

  def dimension; end
  def get_axis(_dimension_); end
  def get_units(_dimension_); end
end

class RGeo::CoordSys::CS::CoordinateSystemFactory
  def create_compound_coordinate_system(name_, head_, tail_); end
  def create_ellipsoid(name_, semi_major_axis_, semi_minor_axis_, linear_unit_); end
  def create_flattened_sphere(name_, semi_major_axis_, inverse_flattening_, linear_unit_); end
  def create_from_wkt(str_); end
  def create_geographic_coordinate_system(name_, angular_unit_, horizontal_datum_, prime_meridian_, axis0_, axis1_); end
  def create_horizontal_datum(name_, horizontal_datum_type_, ellipsoid_, to_wgs84_); end
  def create_local_coordinate_system(name_, datum_, unit_, axes_); end
  def create_local_datum(_name_, local_datum_type_); end
  def create_prime_meridian(_name_, angular_unit_, longitude_); end
  def create_projected_coordinate_system(name_, gcs_, projection_, linear_unit_, axis0_, axis1_); end
  def create_projection(name_, wkt_projection_class_, parameters_); end
  def create_vertical_coordinate_system(name_, vertical_datum_, vertical_unit_, axis_); end
  def create_vertical_datum(name_, vertical_datum_type_); end
end

class RGeo::CoordSys::CS::Datum < ::RGeo::CoordSys::CS::Info
  def initialize(name_, datum_type_, *optional_); end

  def _wkt_content(_open_, _close_); end
  def datum_type; end
end

class RGeo::CoordSys::CS::Ellipsoid < ::RGeo::CoordSys::CS::Info
  def initialize(name_, semi_major_axis_, semi_minor_axis_, inverse_flattening_, ivf_definitive_, linear_unit_, *optional_); end

  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end
  def axis_unit; end
  def inverse_flattening; end
  def ivf_definitive; end
  def semi_major_axis; end
  def semi_minor_axis; end

  class << self
    def create(name_, semi_major_axis_, semi_minor_axis_, inverse_flattening_, ivf_definitive_, linear_unit_, *optional_); end
    def create_ellipsoid(name_, semi_major_axis_, semi_minor_axis_, linear_unit_, *optional_); end
    def create_flattened_sphere(name_, semi_major_axis_, inverse_flattening_, linear_unit_, *optional_); end
  end
end

class RGeo::CoordSys::CS::GeocentricCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name_, horizontal_datum_, prime_meridian_, linear_unit_, axis0_, axis1_, axis2_, *optional_); end

  def _wkt_content(open_, close_); end
  def _wkt_typename; end
  def get_axis(index_); end
  def get_units(_index_); end
  def horizontal_datum; end
  def linear_unit; end
  def prime_meridian; end

  class << self
    def create(name_, horizontal_datum_, prime_meridian_, linear_unit_, axis0_, axis1_, axis2_, *optional_); end
  end
end

class RGeo::CoordSys::CS::GeographicCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  def initialize(name_, angular_unit_, horizontal_datum_, prime_meridian_, axis0_, axis1_, *optional_); end

  def _wkt_content(open_, close_); end
  def _wkt_typename; end
  def angular_unit; end
  def get_axis(index_); end
  def get_units(_index_); end
  def get_wgs84_conversion_info(_index_); end
  def num_conversion_to_wgs84; end
  def prime_meridian; end

  class << self
    def create(name_, angular_unit_, horizontal_datum_, prime_meridian_, axis0_, axis1_, *optional_); end
  end
end

RGeo::CoordSys::CS::HD_CLASSIC = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::HD_GEOCENTRIC = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::HD_MAX = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::HD_MIN = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::HD_OTHER = T.let(T.unsafe(nil), Fixnum)

class RGeo::CoordSys::CS::HorizontalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name_, horizontal_datum_, *optional_); end

  def horizontal_datum; end
end

class RGeo::CoordSys::CS::HorizontalDatum < ::RGeo::CoordSys::CS::Datum
  def initialize(name_, datum_type_, ellipsoid_, wgs84_parameters_, *optional_); end

  def _wkt_content(open_, close_); end
  def _wkt_typename; end
  def ellipsoid; end
  def wgs84_parameters; end

  class << self
    def create(name_, datum_type_, ellipsoid_, wgs84_parameters_, *optional_); end
  end
end

class RGeo::CoordSys::CS::Info < ::RGeo::CoordSys::CS::Base
  def initialize(name_, authority_ = T.unsafe(nil), authority_code_ = T.unsafe(nil), abbreviation_ = T.unsafe(nil), alias_ = T.unsafe(nil), remarks_ = T.unsafe(nil), extensions_ = T.unsafe(nil)); end

  def abbreviation; end
  def alias; end
  def authority; end
  def authority_code; end
  def extension(key_); end
  def name; end
  def remarks; end
end

RGeo::CoordSys::CS::LD_MAX = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::LD_MIN = T.let(T.unsafe(nil), Fixnum)

class RGeo::CoordSys::CS::LinearUnit < ::RGeo::CoordSys::CS::Unit
  def meters_per_unit; end

  class << self
    def create(name_, meters_per_unit_, *optional_); end
  end
end

class RGeo::CoordSys::CS::LocalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name_, local_datum_, unit_, axes_, *optional_); end

  def _wkt_content(open_, close_); end
  def _wkt_typename; end
  def get_axis(index_); end
  def get_units(_index_); end
  def local_datum; end

  class << self
    def create(name_, local_datum_, unit_, axes_, *optional_); end
  end
end

class RGeo::CoordSys::CS::LocalDatum < ::RGeo::CoordSys::CS::Datum
  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end

  class << self
    def create(name_, datum_type_, *optional_); end
  end
end

class RGeo::CoordSys::CS::PrimeMeridian < ::RGeo::CoordSys::CS::Info
  def initialize(name_, angular_unit_, longitude_, *optional_); end

  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end
  def angular_unit; end
  def longitude; end

  class << self
    def create(name_, angular_unit_, longitude_, *optional_); end
  end
end

class RGeo::CoordSys::CS::ProjectedCoordinateSystem < ::RGeo::CoordSys::CS::HorizontalCoordinateSystem
  def initialize(name_, geographic_coordinate_system_, projection_, linear_unit_, axis0_, axis1_, *optional_); end

  def _wkt_content(open_, close_); end
  def _wkt_typename; end
  def geographic_coordinate_system; end
  def get_axis(index_); end
  def get_units(_index_); end
  def linear_unit; end
  def projection; end

  class << self
    def create(name_, geographic_coordinate_system_, projection_, linear_unit_, axis0_, axis1_, *optional_); end
  end
end

class RGeo::CoordSys::CS::Projection < ::RGeo::CoordSys::CS::Info
  def initialize(name_, class_name_, parameters_, *optional_); end

  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end
  def class_name; end
  def each_parameter(&block_); end
  def get_parameter(index_); end
  def num_parameters; end

  class << self
    def create(name_, class_name_, parameters_, *optional_); end
  end
end

class RGeo::CoordSys::CS::ProjectionParameter < ::RGeo::CoordSys::CS::Base
  def initialize(name_, value_); end

  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end
  def name; end
  def value; end

  class << self
    def create(name_, value_); end
  end
end

class RGeo::CoordSys::CS::Unit < ::RGeo::CoordSys::CS::Info
  def initialize(name_, conversion_factor_, *optional_); end

  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end
  def conversion_factor; end

  class << self
    def create(name_, conversion_factor_, *optional_); end
  end
end

RGeo::CoordSys::CS::VD_ALTITUDE_BAROMETRIC = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_DEPTH = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_ELLIPSOIDAL = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_GEOID_MODE_DERIVED = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_MAX = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_MIN = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_NORMAL = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_ORTHOMETRIC = T.let(T.unsafe(nil), Fixnum)

RGeo::CoordSys::CS::VD_OTHER = T.let(T.unsafe(nil), Fixnum)

class RGeo::CoordSys::CS::VerticalCoordinateSystem < ::RGeo::CoordSys::CS::CoordinateSystem
  def initialize(name_, vertical_datum_, vertical_unit_, axis_, *optional_); end

  def _wkt_content(open_, close_); end
  def _wkt_typename; end
  def get_axis(_index_); end
  def get_units(_index_); end
  def vertical_datum; end
  def vertical_unit; end

  class << self
    def create(name_, vertical_datum_, vertical_unit_, axis_, *optional_); end
  end
end

class RGeo::CoordSys::CS::VerticalDatum < ::RGeo::CoordSys::CS::Datum
  def _wkt_content(_open_, _close_); end
  def _wkt_typename; end

  class << self
    def create(name_, datum_type_, *optional_); end
  end
end

class RGeo::CoordSys::CS::WGS84ConversionInfo < ::RGeo::CoordSys::CS::Base
  def initialize(dx_, dy_, dz_, ex_, ey_, ez_, ppm_); end

  def _to_wkt(open_, close_); end
  def dx; end
  def dy; end
  def dz; end
  def ex; end
  def ey; end
  def ez; end
  def ppm; end

  class << self
    def create(dx_, dy_, dz_, ex_, ey_, ez_, ppm_); end
  end
end

class RGeo::CoordSys::CS::WKTParser
  def initialize(str_); end

  def consume_token_type(type_); end
  def cur_token; end
  def expect_token_type(type_); end
  def next_token; end
  def parse(containing_type_ = T.unsafe(nil)); end
end

class RGeo::CoordSys::CS::WKTParser::ArgumentList
  def initialize; end

  def <<(value_); end
  def assert_empty; end
  def create_optionals; end
  def find_all(klass_); end
  def find_first(klass_); end
  def shift(klass_ = T.unsafe(nil)); end
end

class RGeo::CoordSys::CS::WKTParser::AuthorityClause
  def initialize(name_, code_); end

  def to_a; end
end

class RGeo::CoordSys::CS::WKTParser::ExtensionClause
  def initialize(key_, value_); end

  def key; end
  def value; end
end

class RGeo::CoordSys::CS::WKTParser::QuotedString < ::String
end

class RGeo::CoordSys::CS::WKTParser::TypeString < ::String
end

class RGeo::CoordSys::Proj4
  def ==(rhs_); end
  def _canonical_str; end
  def _geocentric?; end
  def _geographic?; end
  def _get_geographic; end
  def _original_str; end
  def _radians?; end
  def _set_value(_, _); end
  def _valid?; end
  def canonical_hash; end
  def canonical_str; end
  def encode_with(coder_); end
  def eql?(rhs_); end
  def geocentric?; end
  def geographic?; end
  def get_geographic; end
  def hash; end
  def init_with(coder_); end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data_); end
  def original_str; end
  def radians?; end
  def to_s; end

  private

  def _create(_, _); end
  def _proj_version; end
  def _transform_coords(_, _, _, _, _); end
  def initialize_copy(_); end

  class << self
    def _create(_, _); end
    def _proj_version; end
    def _transform_coords(_, _, _, _, _); end
    def _transform_linear_ring(from_proj_, from_ring_, to_proj_, to_factory_); end
    def _transform_point(from_proj_, from_point_, to_proj_, to_factory_); end
    def _transform_polygon(from_proj_, from_polygon_, to_proj_, to_factory_); end
    def create(defn_, opts_ = T.unsafe(nil)); end
    def new(defn_, opts_ = T.unsafe(nil)); end
    def supported?; end
    def transform(from_proj_, from_geometry_, to_proj_, to_factory_); end
    def transform_coords(from_proj_, to_proj_, x_, y_, z_ = T.unsafe(nil)); end
    def version; end
  end
end

module RGeo::CoordSys::SRSDatabase
end

class RGeo::CoordSys::SRSDatabase::Entry
  def initialize(ident_, data_ = T.unsafe(nil)); end

  def authority; end
  def authority_code; end
  def coord_sys; end
  def description; end
  def identifier; end
  def name; end
  def proj4; end
end

module RGeo::CoordSys::SRSDatabase::Interface
  def clear_cache; end
  def get(_ident_); end
end

class RGeo::CoordSys::SRSDatabase::Proj4Data
  def initialize(filename_, opts_ = T.unsafe(nil)); end

  def _search_file(ident_); end
  def clear_cache; end
  def get(ident_); end
end

class RGeo::CoordSys::SRSDatabase::SrOrg
  def initialize(catalog_, opts_ = T.unsafe(nil)); end

  def catalog; end
  def clear_cache; end
  def get(ident_); end
end

class RGeo::CoordSys::SRSDatabase::UrlReader
  def initialize(opts_ = T.unsafe(nil)); end

  def clear_cache; end
  def get(ident_); end
end

module RGeo::Error
end

class RGeo::Error::InvalidGeometry < ::RGeo::Error::RGeoError
end

class RGeo::Error::ParseError < ::RGeo::Error::RGeoError
end

class RGeo::Error::RGeoError < ::RuntimeError
end

class RGeo::Error::UnsupportedOperation < ::RGeo::Error::RGeoError
end

module RGeo::Feature
  class << self
    def cast(obj_, *params_); end
  end
end

module RGeo::Feature::Curve
  include(::RGeo::Feature::Geometry)
  extend(::RGeo::Feature::Type)

  def end_point; end
  def is_closed?; end
  def is_ring?; end
  def length; end
  def start_point; end
end

module RGeo::Feature::Factory
  def collection(_elems_); end
  def coord_sys; end
  def line(_start_, _end_); end
  def line_string(_points_); end
  def linear_ring(_points_); end
  def multi_line_string(_elems_); end
  def multi_point(_elems_); end
  def multi_polygon(_elems_); end
  def override_cast(_original_, _type_, _flags_); end
  def parse_wkb(_str_); end
  def parse_wkt(_str_); end
  def point(_x_, _y_, *_extra_); end
  def polygon(_outer_ring_, _inner_rings_ = T.unsafe(nil)); end
  def proj4; end
  def property(_name_); end
end

module RGeo::Feature::Factory::Instance
end

module RGeo::Feature::FactoryGenerator
  def call(_config_ = T.unsafe(nil)); end

  class << self
    def decorate(delegate_, default_config_ = T.unsafe(nil), force_config_ = T.unsafe(nil)); end
    def single(factory_); end
  end
end

module RGeo::Feature::Geometry
  extend(::RGeo::Feature::Type)

  def *(rhs_); end
  def +(rhs_); end
  def -(rhs_); end
  def ==(rhs_); end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(_distance_); end
  def contains?(_another_geometry_); end
  def convex_hull; end
  def crosses?(_another_geometry_); end
  def difference(_another_geometry_); end
  def dimension; end
  def disjoint?(_another_geometry_); end
  def distance(_another_geometry_); end
  def envelope; end
  def eql?(rhs_); end
  def equals?(_another_geometry_); end
  def factory; end
  def geometry_type; end
  def intersection(_another_geometry_); end
  def intersects?(_another_geometry_); end
  def is_empty?; end
  def is_simple?; end
  def overlaps?(_another_geometry_); end
  def relate(another_geometry_, intersection_pattern_matrix_); end
  def relate?(_another_geometry_, _intersection_pattern_matrix_); end
  def rep_equals?(_another_geometry_); end
  def srid; end
  def sym_difference(_another_geometry_); end
  def touches?(_another_geometry_); end
  def unary_union; end
  def union(_another_geometry_); end
  def within?(_another_geometry_); end
end

module RGeo::Feature::GeometryCollection
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  extend(::RGeo::Feature::Type)

  def [](_n_); end
  def each(&_block_); end
  def geometry_n(_n_); end
  def num_geometries; end
  def size; end
end

module RGeo::Feature::Instance
end

module RGeo::Feature::Line
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  extend(::RGeo::Feature::Type)
end

module RGeo::Feature::LineString
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  extend(::RGeo::Feature::Type)

  def num_points; end
  def point_n(_n_); end
  def points; end
end

module RGeo::Feature::LinearRing
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  extend(::RGeo::Feature::Type)
end

class RGeo::Feature::MixinCollection
  def initialize; end

  def add(type_, module_); end
  def for_type(type_); end
  def include_in_class(type_, klass_, include_ancestry_ = T.unsafe(nil)); end
  def include_in_object(type_, obj_, include_ancestry_ = T.unsafe(nil)); end
end

RGeo::Feature::MixinCollection::GLOBAL = T.let(T.unsafe(nil), RGeo::Feature::MixinCollection)

class RGeo::Feature::MixinCollection::TypeData
  def initialize(collection_, type_); end

  def _radd(module_); end
  def add(module_); end
  def collection; end
  def include_in_class(klass_, include_ancestry_ = T.unsafe(nil)); end
  def include_in_object(obj_, include_ancestry_ = T.unsafe(nil)); end
  def type; end
end

module RGeo::Feature::MultiCurve
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  extend(::RGeo::Feature::Type)

  def is_closed?; end
  def length; end
end

module RGeo::Feature::MultiLineString
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiCurve)
  extend(::RGeo::Feature::Type)
end

module RGeo::Feature::MultiPoint
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  extend(::RGeo::Feature::Type)
end

module RGeo::Feature::MultiPolygon
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiSurface)
  extend(::RGeo::Feature::Type)
end

module RGeo::Feature::MultiSurface
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  extend(::RGeo::Feature::Type)

  def area; end
  def centroid; end
  def point_on_surface; end
end

module RGeo::Feature::Point
  include(::RGeo::Feature::Geometry)
  extend(::RGeo::Feature::Type)

  def m; end
  def x; end
  def y; end
  def z; end
end

module RGeo::Feature::Polygon
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Surface)
  extend(::RGeo::Feature::Type)

  def exterior_ring; end
  def interior_ring_n(_n_); end
  def interior_rings; end
  def num_interior_rings; end
end

module RGeo::Feature::Surface
  include(::RGeo::Feature::Geometry)
  extend(::RGeo::Feature::Type)

  def area; end
  def centroid; end
  def point_on_surface; end
end

module RGeo::Feature::Type
  def ===(rhs_); end
  def _add_subtype(type_); end
  def check_type(rhs_); end
  def each_immediate_subtype(&block_); end
  def subtype_of?(type_); end
  def supertype; end
  def to_s; end
  def type_name; end

  class << self
    def extended(type_); end
  end
end

RGeo::Feature::Type::Instance = RGeo::Feature::Instance

module RGeo::Geographic
  class << self
    def _coordsys_4055; end
    def _coordsys_4326; end
    def _proj4_4055; end
    def _proj4_4326; end
    def projected_factory(opts_ = T.unsafe(nil)); end
    def simple_mercator_factory(opts_ = T.unsafe(nil)); end
    def spherical_factory(opts_ = T.unsafe(nil)); end
  end
end

class RGeo::Geographic::Factory
  include(::RGeo::Feature::Factory::Instance)

  def initialize(impl_prefix_, opts_ = T.unsafe(nil)); end

  def ==(rhs_); end
  def _generate_wkb(obj_); end
  def _generate_wkt(obj_); end
  def _marshal_wkb_generator; end
  def _marshal_wkb_parser; end
  def _psych_wkt_generator; end
  def _psych_wkt_parser; end
  def _set_projector(projector_); end
  def collection(elems_); end
  def coord_sys; end
  def encode_with(coder_); end
  def eql?(rhs_); end
  def has_projection?; end
  def hash; end
  def init_with(coder_); end
  def line(start_, end_); end
  def line_string(points_); end
  def linear_ring(points_); end
  def marshal_dump; end
  def marshal_load(data_); end
  def multi_line_string(elems_); end
  def multi_point(elems_); end
  def multi_polygon(elems_); end
  def parse_wkb(str_); end
  def parse_wkt(str_); end
  def point(x_, y_, *extra_); end
  def polygon(outer_ring_, inner_rings_ = T.unsafe(nil)); end
  def proj4; end
  def project(geometry_); end
  def projection_factory; end
  def projection_limits_window; end
  def projection_wraps?; end
  def property(name_); end
  def srid; end
  def unproject(geometry_); end
end

class RGeo::Geographic::Proj4Projector
  def initialize(geography_factory_, projection_factory_); end

  def _set_factories(geography_factory_, projection_factory_); end
  def limits_window; end
  def project(geometry_); end
  def projection_factory; end
  def unproject(geometry_); end
  def wraps?; end

  class << self
    def create_from_existing_factory(geography_factory_, projection_factory_); end
    def create_from_proj4(geography_factory_, proj4_, opts_ = T.unsafe(nil)); end
  end
end

class RGeo::Geographic::ProjectedGeometryCollectionImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::ProjectedGeometryMethods
  def boundary; end
  def buffer(distance_); end
  def buffer_with_style(distance_, endCapStyle_, joinStyle_, mitreLimit_); end
  def contains?(rhs_); end
  def convex_hull; end
  def crosses?(rhs_); end
  def difference(rhs_); end
  def disjoint?(rhs_); end
  def distance(rhs_); end
  def envelope; end
  def equals?(rhs_); end
  def intersection(rhs_); end
  def intersects?(rhs_); end
  def is_empty?; end
  def is_simple?; end
  def overlaps?(rhs_); end
  def projection; end
  def relate(rhs_, pattern_); end
  def simplify(tolerance_); end
  def simplify_preserve_topology(tolerance_); end
  def srid; end
  def sym_difference(rhs_); end
  def touches?(rhs_); end
  def union(rhs_); end
  def within?(rhs_); end
end

class RGeo::Geographic::ProjectedLineImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::Line)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::ImplHelper::BasicLineMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::Geographic::ProjectedNCurveMethods)
  include(::RGeo::Geographic::ProjectedLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geographic::ProjectedLineStringImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::Geographic::ProjectedNCurveMethods)
  include(::RGeo::Geographic::ProjectedLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::ProjectedLineStringMethods
  def _validate_geometry; end
end

class RGeo::Geographic::ProjectedLinearRingImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::LinearRing)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::ImplHelper::BasicLinearRingMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::Geographic::ProjectedNCurveMethods)
  include(::RGeo::Geographic::ProjectedLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geographic::ProjectedMultiLineStringImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiCurve)
  include(::RGeo::Feature::MultiLineString)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiLineStringMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::Geographic::ProjectedNCurveMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geographic::ProjectedMultiPointImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiPoint)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiPointMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geographic::ProjectedMultiPolygonImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiSurface)
  include(::RGeo::Feature::MultiPolygon)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiPolygonMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::Geographic::ProjectedNSurfaceMethods)
  include(::RGeo::Geographic::ProjectedMultiPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::ProjectedMultiPolygonMethods
  def _validate_geometry; end
end

module RGeo::Geographic::ProjectedNCurveMethods
  def length; end
end

module RGeo::Geographic::ProjectedNSurfaceMethods
  def area; end
  def centroid; end
  def point_on_surface; end
end

class RGeo::Geographic::ProjectedPointImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Point)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicPointMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::Geographic::ProjectedPointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)

  def lat; end
  def latitude; end
  def lon; end
  def longitude; end
end

module RGeo::Geographic::ProjectedPointMethods
  def _validate_geometry; end
  def canonical_lon; end
  def canonical_longitude; end
  def canonical_point; end
  def canonical_x; end

  class << self
    def included(klass_); end
  end
end

class RGeo::Geographic::ProjectedPolygonImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Surface)
  include(::RGeo::Feature::Polygon)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicPolygonMethods)
  include(::RGeo::Geographic::ProjectedGeometryMethods)
  include(::RGeo::Geographic::ProjectedNSurfaceMethods)
  include(::RGeo::Geographic::ProjectedPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::ProjectedPolygonMethods
  def _validate_geometry; end
end

class RGeo::Geographic::ProjectedWindow
  def initialize(factory_, x_min_, y_min_, x_max_, y_max_, opts_ = T.unsafe(nil)); end

  def *(x_factor_, y_factor_ = T.unsafe(nil)); end
  def ==(obj_); end
  def center_point; end
  def center_xy; end
  def clamped_by(min_width_, min_height_, max_width_, max_height_); end
  def contains_point?(point_); end
  def contains_window?(window_); end
  def crosses_seam?; end
  def degenerate?; end
  def eql?(obj_); end
  def factory; end
  def hash; end
  def height; end
  def inspect; end
  def ne_point; end
  def nw_point; end
  def random_point; end
  def scaled_by(x_factor_, y_factor_ = T.unsafe(nil)); end
  def se_point; end
  def sw_point; end
  def to_s; end
  def width; end
  def with_margin(x_margin_, y_margin_ = T.unsafe(nil)); end
  def x_max; end
  def x_min; end
  def x_span; end
  def y_max; end
  def y_min; end
  def y_span; end

  class << self
    def bounding_points(points_); end
    def for_corners(sw_, ne_); end
    def surrounding_point(point_, x_margin_ = T.unsafe(nil), y_margin_ = T.unsafe(nil)); end
  end
end

class RGeo::Geographic::SimpleMercatorProjector
  def initialize(geography_factory_, opts_ = T.unsafe(nil)); end

  def _set_factories(geography_factory_, projection_factory_); end
  def limits_window; end
  def project(geometry_); end
  def projection_factory; end
  def unproject(geometry_); end
  def wraps?; end

  class << self
    def _coordsys_3857; end
    def _proj4_3857; end
  end
end

RGeo::Geographic::SimpleMercatorProjector::EQUATORIAL_RADIUS = T.let(T.unsafe(nil), Float)

class RGeo::Geographic::SphericalGeometryCollectionImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::SphericalGeometryMethods
  def srid; end
end

class RGeo::Geographic::SphericalLineImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::Line)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::ImplHelper::BasicLineMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::Geographic::SphericalLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geographic::SphericalLineStringImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::Geographic::SphericalLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::SphericalLineStringMethods
  def _arcs; end
  def is_simple?; end
  def length; end
end

class RGeo::Geographic::SphericalLinearRingImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Curve)
  include(::RGeo::Feature::LineString)
  include(::RGeo::Feature::LinearRing)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicLineStringMethods)
  include(::RGeo::ImplHelper::BasicLinearRingMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::Geographic::SphericalLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::SphericalMath
end

class RGeo::Geographic::SphericalMath::ArcXYZ
  def initialize(start_, end_); end

  def ==(rhs_); end
  def axis; end
  def contains_point?(obj_); end
  def degenerate?; end
  def e; end
  def eql?(rhs_); end
  def intersects_arc?(obj_); end
  def length; end
  def s; end
  def to_s; end
end

class RGeo::Geographic::SphericalMath::PointXYZ
  def initialize(x_, y_, z_); end

  def %(rhs_); end
  def *(rhs_); end
  def ==(rhs_); end
  def create_perpendicular; end
  def dist_to_point(rhs_); end
  def eql?(rhs_); end
  def latlon; end
  def lonlat; end
  def to_s; end
  def x; end
  def y; end
  def z; end

  class << self
    def from_latlon(lat_, lon_); end
    def weighted_combination(p1_, w1_, p2_, w2_); end
  end
end

RGeo::Geographic::SphericalMath::PointXYZ::P1 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)

RGeo::Geographic::SphericalMath::PointXYZ::P2 = T.let(T.unsafe(nil), RGeo::Geographic::SphericalMath::PointXYZ)

RGeo::Geographic::SphericalMath::RADIUS = T.let(T.unsafe(nil), Float)

class RGeo::Geographic::SphericalMultiLineStringImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiCurve)
  include(::RGeo::Feature::MultiLineString)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiLineStringMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::Geographic::SphericalMultiLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geographic::SphericalMultiLineStringMethods
  def length; end
end

class RGeo::Geographic::SphericalMultiPointImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiPoint)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiPointMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geographic::SphericalMultiPolygonImpl
  include(::RGeo::Feature::Geometry)
  include(::Enumerable)
  include(::RGeo::Feature::GeometryCollection)
  include(::RGeo::Feature::MultiSurface)
  include(::RGeo::Feature::MultiPolygon)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicGeometryCollectionMethods)
  include(::RGeo::ImplHelper::BasicMultiPolygonMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geographic::SphericalPointImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Point)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicPointMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::Geographic::SphericalPointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)

  def lat; end
  def latitude; end
  def lon; end
  def longitude; end
end

module RGeo::Geographic::SphericalPointMethods
  def _validate_geometry; end
  def _xyz; end
  def buffer(distance_); end
  def distance(rhs_); end
  def equals?(rhs_); end

  class << self
    def included(klass_); end
  end
end

class RGeo::Geographic::SphericalPolygonImpl
  include(::RGeo::Feature::Geometry)
  include(::RGeo::Feature::Surface)
  include(::RGeo::Feature::Polygon)
  include(::RGeo::Feature::Instance)
  include(::RGeo::ImplHelper::BasicGeometryMethods)
  include(::RGeo::ImplHelper::BasicPolygonMethods)
  include(::RGeo::Geographic::SphericalGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos
  class << self
    def capi_supported?; end
    def factory(opts_ = T.unsafe(nil)); end
    def factory_generator(defaults_ = T.unsafe(nil)); end
    def ffi_supported?; end
    def is_capi_geos?(object_); end
    def is_ffi_geos?(object_); end
    def is_geos?(object_); end
    def preferred_native_interface; end
    def preferred_native_interface=(_); end
    def supported?; end
    def version; end
  end
end

class RGeo::Geos::CAPIFactory
  include(::RGeo::Feature::Factory::Instance)

  def ==(rhs_); end
  def _buffer_resolution; end
  def _coord_sys; end
  def _flags; end
  def _parse_wkb_impl(_); end
  def _parse_wkt_impl(_); end
  def _proj4; end
  def _read_for_marshal(_); end
  def _read_for_psych(_); end
  def _set_wkrep_parsers(_, _); end
  def _srid; end
  def _wkb_generator; end
  def _wkb_parser; end
  def _wkt_generator; end
  def _wkt_parser; end
  def _write_for_marshal(_); end
  def _write_for_psych(_); end
  def buffer_resolution; end
  def collection(elems_); end
  def coord_sys; end
  def encode_with(coder_); end
  def eql?(rhs_); end
  def hash; end
  def init_with(coder_); end
  def inspect; end
  def lenient_multi_polygon_assertions?; end
  def line(start_, end_); end
  def line_string(points_); end
  def linear_ring(points_); end
  def marshal_dump; end
  def marshal_load(data_); end
  def multi_line_string(elems_); end
  def multi_point(elems_); end
  def multi_polygon(elems_); end
  def override_cast(original_, ntype_, flags_); end
  def parse_wkb(str_); end
  def parse_wkt(str_); end
  def point(x_, y_, *extra_); end
  def polygon(outer_ring_, inner_rings_ = T.unsafe(nil)); end
  def proj4; end
  def property(name_); end
  def srid; end

  private

  def _create(_, _, _, _, _, _, _); end
  def _geos_version; end
  def _supports_unary_union?; end
  def initialize_copy(_); end

  class << self
    def _create(_, _, _, _, _, _, _); end
    def _geos_version; end
    def _supports_unary_union?; end
    def create(opts_ = T.unsafe(nil)); end
    def new(opts_ = T.unsafe(nil)); end
  end
end

RGeo::Geos::CAPIFactory::IMPL_CLASSES = T.let(T.unsafe(nil), Hash)

RGeo::Geos::CAPIFactory::INTERNAL_CGLOBALS = T.let(T.unsafe(nil), Object)

class RGeo::Geos::CAPIGeometryCollectionImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::CAPIGeometryCollectionMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def create(_, _); end

  class << self
    def create(_, _); end
  end
end

module RGeo::Geos::CAPIGeometryCollectionMethods
  include(::Enumerable)

  def [](_); end
  def each; end
  def eql?(_); end
  def geometry_n(_); end
  def geometry_type; end
  def hash; end
  def num_geometries; end
  def rep_equals?(_); end
  def size; end
end

class RGeo::Geos::CAPIGeometryImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::CAPIGeometryMethods
  include(::RGeo::Feature::Instance)

  def *(_); end
  def +(_); end
  def -(_); end
  def ==(_); end
  def _as_text; end
  def _set_factory(_); end
  def _steal(_); end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(_); end
  def buffer_with_style(_, _, _, _); end
  def contains?(_); end
  def convex_hull; end
  def crosses?(_); end
  def difference(_); end
  def dimension; end
  def disjoint?(_); end
  def distance(_); end
  def encode_with(coder_); end
  def envelope; end
  def eql?(_); end
  def equals?(_); end
  def factory; end
  def geometry_type; end
  def init_with(coder_); end
  def initialized?; end
  def inspect; end
  def intersection(_); end
  def intersects?(_); end
  def invalid_reason; end
  def is_empty?; end
  def is_simple?; end
  def marshal_dump; end
  def marshal_load(data_); end
  def overlaps?(_); end
  def prepare!; end
  def prepared?; end
  def relate?(_, _); end
  def rep_equals?(_); end
  def simplify(_); end
  def simplify_preserve_topology(_); end
  def srid; end
  def sym_difference(_); end
  def to_s; end
  def touches?(_); end
  def unary_union; end
  def union(_); end
  def valid?; end
  def within?(_); end

  private

  def initialize_copy(_); end
end

class RGeo::Geos::CAPILineImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::RGeo::Geos::CAPILineStringMethods)
  include(::RGeo::Geos::CAPILineMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def _copy_from(_, _); end
  def create(_, _, _); end

  class << self
    def _copy_from(_, _); end
    def create(_, _, _); end
  end
end

module RGeo::Geos::CAPILineMethods
  def geometry_type; end
  def hash; end
end

class RGeo::Geos::CAPILineStringImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::RGeo::Geos::CAPILineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def _copy_from(_, _); end
  def create(_, _); end

  class << self
    def _copy_from(_, _); end
    def create(_, _); end
  end
end

module RGeo::Geos::CAPILineStringMethods
  def coordinates; end
  def end_point; end
  def eql?(_); end
  def geometry_type; end
  def hash; end
  def is_closed?; end
  def is_ring?; end
  def length; end
  def num_points; end
  def point_n(_); end
  def points; end
  def rep_equals?(_); end
  def start_point; end
end

class RGeo::Geos::CAPILinearRingImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::RGeo::Geos::CAPILineStringMethods)
  include(::RGeo::Geos::CAPILinearRingMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def _copy_from(_, _); end
  def create(_, _); end

  class << self
    def _copy_from(_, _); end
    def create(_, _); end
  end
end

module RGeo::Geos::CAPILinearRingMethods
  def geometry_type; end
  def hash; end
end

class RGeo::Geos::CAPIMultiLineStringImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::CAPIGeometryCollectionMethods)
  include(::RGeo::Geos::CAPIMultiLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def create(_, _); end

  class << self
    def create(_, _); end
  end
end

module RGeo::Geos::CAPIMultiLineStringMethods
  def coordinates; end
  def geometry_type; end
  def hash; end
  def is_closed?; end
  def length; end
end

class RGeo::Geos::CAPIMultiPointImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::CAPIGeometryCollectionMethods)
  include(::RGeo::Geos::CAPIMultiPointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def create(_, _); end

  class << self
    def create(_, _); end
  end
end

module RGeo::Geos::CAPIMultiPointMethods
  def coordinates; end
  def geometry_type; end
  def hash; end
end

class RGeo::Geos::CAPIMultiPolygonImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::CAPIGeometryCollectionMethods)
  include(::RGeo::Geos::CAPIMultiPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def create(_, _); end

  class << self
    def create(_, _); end
  end
end

module RGeo::Geos::CAPIMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def geometry_type; end
  def hash; end
  def point_on_surface; end
end

class RGeo::Geos::CAPIPointImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::RGeo::Geos::CAPIPointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def create(_, _, _, _); end

  class << self
    def create(_, _, _, _); end
  end
end

module RGeo::Geos::CAPIPointMethods
  def coordinates; end
  def eql?(_); end
  def geometry_type; end
  def hash; end
  def m; end
  def rep_equals?(_); end
  def x; end
  def y; end
  def z; end
end

class RGeo::Geos::CAPIPolygonImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::CAPIGeometryMethods)
  include(::RGeo::Geos::CAPIPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)


  private

  def create(_, _, _); end

  class << self
    def create(_, _, _); end
  end
end

module RGeo::Geos::CAPIPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def eql?(_); end
  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(_); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end
  def rep_equals?(_); end
end

RGeo::Geos::CAPI_SUPPORTED = T.let(T.unsafe(nil), TrueClass)

RGeo::Geos::CAP_FLAT = T.let(T.unsafe(nil), Fixnum)

RGeo::Geos::CAP_ROUND = T.let(T.unsafe(nil), Fixnum)

RGeo::Geos::CAP_SQUARE = T.let(T.unsafe(nil), Fixnum)

class RGeo::Geos::FFIFactory
  include(::RGeo::Feature::Factory::Instance)

  def initialize(opts_ = T.unsafe(nil)); end

  def ==(rhs_); end
  def _auto_prepare; end
  def _convert_to_fg_geometry(obj_, type_ = T.unsafe(nil)); end
  def _create_fg_linear_ring(points_); end
  def _generate_wkb(geom_); end
  def _generate_wkt(geom_); end
  def _has_3d; end
  def _read_for_marshal(str_); end
  def _read_for_psych(str_); end
  def _wrap_fg_geom(fg_geom_, klass_); end
  def _write_for_marshal(geom_); end
  def _write_for_psych(geom_); end
  def buffer_resolution; end
  def collection(elems_); end
  def coord_sys; end
  def encode_with(coder_); end
  def eql?(rhs_); end
  def hash; end
  def init_with(coder_); end
  def inspect; end
  def lenient_multi_polygon_assertions?; end
  def line(start_, end_); end
  def line_string(points_); end
  def linear_ring(points_); end
  def marshal_dump; end
  def marshal_load(data_); end
  def multi_line_string(elems_); end
  def multi_point(elems_); end
  def multi_polygon(elems_); end
  def override_cast(_original_, _ntype_, _flags_); end
  def parse_wkb(str_); end
  def parse_wkt(str_); end
  def point(x_, y_, z_ = T.unsafe(nil)); end
  def polygon(outer_ring_, inner_rings_ = T.unsafe(nil)); end
  def proj4; end
  def property(name_); end
  def srid; end
  def wrap_fg_geom(fg_geom_); end
end

class RGeo::Geos::FFIGeometryCollectionImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::FFIGeometryCollectionMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFIGeometryCollectionMethods
  include(::Enumerable)

  def [](n_); end
  def each; end
  def geometry_n(n_); end
  def geometry_type; end
  def hash; end
  def num_geometries; end
  def rep_equals?(rhs_); end
  def size; end
end

class RGeo::Geos::FFIGeometryImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFIGeometryMethods
  include(::RGeo::Feature::Instance)

  def initialize(factory_, fg_geom_, klasses_); end

  def *(rhs_); end
  def +(rhs_); end
  def -(rhs_); end
  def ==(rhs_); end
  def _detach_fg_geom; end
  def _klasses; end
  def _request_prepared; end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(distance_); end
  def contains?(rhs_); end
  def convex_hull; end
  def crosses?(rhs_); end
  def difference(rhs_); end
  def dimension; end
  def disjoint?(rhs_); end
  def distance(rhs_); end
  def encode_with(coder_); end
  def envelope; end
  def eql?(rhs_); end
  def equals?(rhs_); end
  def factory; end
  def fg_geom; end
  def geometry_type; end
  def init_with(coder_); end
  def inspect; end
  def intersection(rhs_); end
  def intersects?(rhs_); end
  def is_empty?; end
  def is_simple?; end
  def marshal_dump; end
  def marshal_load(data_); end
  def overlaps?(rhs_); end
  def prepare!; end
  def prepared?; end
  def relate(rhs_, pattern_); end
  def relate?(rhs_, pattern_); end
  def srid; end
  def sym_difference(rhs_); end
  def to_s; end
  def touches?(rhs_); end
  def unary_union; end
  def union(rhs_); end
  def within?(rhs_); end

  private

  def initialize_copy(orig_); end
end

class RGeo::Geos::FFILineImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::RGeo::Geos::FFILineStringMethods)
  include(::RGeo::Geos::FFILineMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFILineMethods
  def geometry_type; end
end

class RGeo::Geos::FFILineStringImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::RGeo::Geos::FFILineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFILineStringMethods
  def coordinates; end
  def end_point; end
  def geometry_type; end
  def hash; end
  def is_closed?; end
  def is_ring?; end
  def length; end
  def num_points; end
  def point_n(n_); end
  def points; end
  def rep_equals?(rhs_); end
  def start_point; end
end

class RGeo::Geos::FFILinearRingImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::RGeo::Geos::FFILineStringMethods)
  include(::RGeo::Geos::FFILinearRingMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFILinearRingMethods
  def geometry_type; end
end

class RGeo::Geos::FFIMultiLineStringImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::FFIGeometryCollectionMethods)
  include(::RGeo::Geos::FFIMultiLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFIMultiLineStringMethods
  def coordinates; end
  def geometry_type; end
  def is_closed?; end
  def length; end
end

class RGeo::Geos::FFIMultiPointImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::FFIGeometryCollectionMethods)
  include(::RGeo::Geos::FFIMultiPointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFIMultiPointMethods
  def coordinates; end
  def geometry_type; end
end

class RGeo::Geos::FFIMultiPolygonImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::FFIGeometryCollectionMethods)
  include(::RGeo::Geos::FFIMultiPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFIMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def geometry_type; end
  def point_on_surface; end
end

class RGeo::Geos::FFIPointImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::RGeo::Geos::FFIPointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFIPointMethods
  def coordinates; end
  def geometry_type; end
  def hash; end
  def m; end
  def rep_equals?(rhs_); end
  def x; end
  def y; end
  def z; end
end

class RGeo::Geos::FFIPolygonImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::FFIGeometryMethods)
  include(::RGeo::Geos::FFIPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::FFIPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(n_); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end
  def rep_equals?(rhs_); end
end

RGeo::Geos::FFI_SUPPORT_EXCEPTION = T.let(T.unsafe(nil), LoadError)

RGeo::Geos::Factory = RGeo::Geos::CAPIFactory

RGeo::Geos::JOIN_BEVEL = T.let(T.unsafe(nil), Fixnum)

RGeo::Geos::JOIN_MITRE = T.let(T.unsafe(nil), Fixnum)

RGeo::Geos::JOIN_ROUND = T.let(T.unsafe(nil), Fixnum)

module RGeo::Geos::Utils
  class << self
    def _init; end
    def ffi_compute_dimension(geom_); end
    def ffi_coord_seq_hash(cs_, hash_ = T.unsafe(nil)); end
    def ffi_coord_seqs_equal?(cs1_, cs2_, check_z_); end
    def ffi_supports_prepared_level_1; end
    def ffi_supports_prepared_level_2; end
    def ffi_supports_set_output_dimension; end
    def ffi_supports_unary_union; end
    def marshal_wkb_generator; end
    def psych_wkt_generator; end
  end
end

class RGeo::Geos::ZMFactory
  include(::RGeo::Feature::Factory::Instance)

  def initialize(opts_ = T.unsafe(nil)); end

  def ==(rhs_); end
  def _create_feature(klass_, zgeometry_, mgeometry_); end
  def _marshal_wkb_generator; end
  def _marshal_wkb_parser; end
  def _psych_wkt_generator; end
  def _psych_wkt_parser; end
  def buffer_resolution; end
  def collection(elems_); end
  def coord_sys; end
  def encode_with(coder_); end
  def eql?(rhs_); end
  def hash; end
  def init_with(coder_); end
  def lenient_multi_polygon_assertions?; end
  def line(start_, end_); end
  def line_string(points_); end
  def linear_ring(points_); end
  def m_factory; end
  def marshal_dump; end
  def marshal_load(data_); end
  def multi_line_string(elems_); end
  def multi_point(elems_); end
  def multi_polygon(elems_); end
  def override_cast(original_, ntype_, flags_); end
  def parse_wkb(str_); end
  def parse_wkt(str_); end
  def point(x_, y_, z_ = T.unsafe(nil), m_ = T.unsafe(nil)); end
  def polygon(outer_ring_, inner_rings_ = T.unsafe(nil)); end
  def proj4; end
  def property(name_); end
  def srid; end
  def z_factory; end

  class << self
    def create(opts_ = T.unsafe(nil)); end
  end
end

RGeo::Geos::ZMFactory::TYPE_KLASSES = T.let(T.unsafe(nil), Hash)

class RGeo::Geos::ZMGeometryCollectionImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::ZMGeometryCollectionMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::ZMGeometryCollectionMethods
  include(::Enumerable)

  def [](n_); end
  def each; end
  def geometry_n(n_); end
  def num_geometries; end
  def size; end
end

class RGeo::Geos::ZMGeometryImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::ZMGeometryMethods
  include(::RGeo::Feature::Instance)

  def initialize(factory_, zgeometry_, mgeometry_); end

  def *(rhs_); end
  def +(rhs_); end
  def -(rhs_); end
  def ==(rhs_); end
  def _copy_state_from(obj_); end
  def as_binary; end
  def as_text; end
  def boundary; end
  def buffer(distance_); end
  def contains?(rhs_); end
  def convex_hull; end
  def crosses?(rhs_); end
  def difference(rhs_); end
  def dimension; end
  def disjoint?(rhs_); end
  def distance(rhs_); end
  def encode_with(coder_); end
  def envelope; end
  def eql?(rhs_); end
  def equals?(rhs_); end
  def factory; end
  def geometry_type; end
  def hash; end
  def init_with(coder_); end
  def inspect; end
  def intersection(rhs_); end
  def intersects?(rhs_); end
  def is_empty?; end
  def is_simple?; end
  def m_geometry; end
  def marshal_dump; end
  def marshal_load(data_); end
  def overlaps?(rhs_); end
  def relate(rhs_, pattern_); end
  def relate?(rhs_, pattern_); end
  def rep_equals?(rhs_); end
  def srid; end
  def sym_difference(rhs_); end
  def to_s; end
  def touches?(rhs_); end
  def union(rhs_); end
  def within?(rhs_); end
  def z_geometry; end
end

class RGeo::Geos::ZMLineImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::RGeo::Geos::ZMLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geos::ZMLineStringImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::RGeo::Geos::ZMLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::ZMLineStringMethods
  def coordinates; end
  def end_point; end
  def is_closed?; end
  def is_ring?; end
  def length; end
  def num_points; end
  def point_n(n_); end
  def points; end
  def start_point; end
end

class RGeo::Geos::ZMLinearRingImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::RGeo::Geos::ZMLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geos::ZMMultiLineStringImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::ZMGeometryCollectionMethods)
  include(::RGeo::Geos::ZMMultiLineStringMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::ZMMultiLineStringMethods
  def coordinates; end
  def is_closed?; end
  def length; end
end

class RGeo::Geos::ZMMultiPointImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::ZMGeometryCollectionMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

class RGeo::Geos::ZMMultiPolygonImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::Enumerable)
  include(::RGeo::Geos::ZMGeometryCollectionMethods)
  include(::RGeo::Geos::ZMMultiPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::ZMMultiPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def point_on_surface; end
end

class RGeo::Geos::ZMPointImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::RGeo::Geos::ZMPointMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::ZMPointMethods
  def coordinates; end
  def m; end
  def x; end
  def y; end
  def z; end
end

class RGeo::Geos::ZMPolygonImpl
  include(::RGeo::Feature::Instance)
  include(::RGeo::Geos::ZMGeometryMethods)
  include(::RGeo::Geos::ZMPolygonMethods)
  include(::RGeo::ActiveRecord::GeometryMixin)
end

module RGeo::Geos::ZMPolygonMethods
  def area; end
  def centroid; end
  def coordinates; end
  def exterior_ring; end
  def interior_ring_n(n_); end
  def interior_rings; end
  def num_interior_rings; end
  def point_on_surface; end
end

module RGeo::ImplHelper
end

module RGeo::ImplHelper::BasicGeometryCollectionMethods
  def initialize(factory_, elements_); end

  def [](n_); end
  def _copy_state_from(obj_); end
  def _elements; end
  def dimension; end
  def each(&block_); end
  def geometry_n(n_); end
  def geometry_type; end
  def hash; end
  def is_empty?; end
  def num_geometries; end
  def rep_equals?(rhs_); end
end

module RGeo::ImplHelper::BasicGeometryMethods
  include(::RGeo::Feature::Instance)

  def _copy_state_from(obj_); end
  def _set_factory(factory_); end
  def _validate_geometry; end
  def as_binary; end
  def as_text; end
  def encode_with(coder_); end
  def factory; end
  def init_with(coder_); end
  def inspect; end
  def marshal_dump; end
  def marshal_load(data_); end
  def to_s; end
end

module RGeo::ImplHelper::BasicLineMethods
  def initialize(factory_, start_, end_); end

  def _validate_geometry; end
  def coordinates; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicLineStringMethods
  def initialize(factory_, points_); end

  def _copy_state_from(obj_); end
  def _validate_geometry; end
  def boundary; end
  def coordinates; end
  def dimension; end
  def end_point; end
  def geometry_type; end
  def hash; end
  def is_closed?; end
  def is_empty?; end
  def is_ring?; end
  def num_points; end
  def point_n(n_); end
  def points; end
  def rep_equals?(rhs_); end
  def start_point; end
end

module RGeo::ImplHelper::BasicLinearRingMethods
  def _validate_geometry; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicMultiLineStringMethods
  def initialize(factory_, elements_); end

  def _add_boundary(hash_, point_); end
  def boundary; end
  def coordinates; end
  def geometry_type; end
  def is_closed?; end
  def length; end
end

module RGeo::ImplHelper::BasicMultiPointMethods
  def initialize(factory_, elements_); end

  def boundary; end
  def coordinates; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicMultiPolygonMethods
  def initialize(factory_, elements_); end

  def area; end
  def boundary; end
  def coordinates; end
  def geometry_type; end
end

module RGeo::ImplHelper::BasicPointMethods
  def initialize(factory_, x_, y_, *extra_); end

  def _copy_state_from(obj_); end
  def boundary; end
  def convex_hull; end
  def coordinates; end
  def dimension; end
  def envelope; end
  def equals?(rhs_); end
  def geometry_type; end
  def hash; end
  def is_empty?; end
  def is_simple?; end
  def m; end
  def rep_equals?(rhs_); end
  def x; end
  def y; end
  def z; end
end

module RGeo::ImplHelper::BasicPolygonMethods
  def initialize(factory_, exterior_ring_, interior_rings_); end

  def _copy_state_from(obj_); end
  def boundary; end
  def coordinates; end
  def dimension; end
  def exterior_ring; end
  def geometry_type; end
  def hash; end
  def interior_ring_n(n_); end
  def interior_rings; end
  def is_empty?; end
  def num_interior_rings; end
  def rep_equals?(rhs_); end
end

module RGeo::ImplHelper::Math
end

RGeo::ImplHelper::Math::DEGREES_PER_RADIAN = T.let(T.unsafe(nil), Float)

RGeo::ImplHelper::Math::RADIANS_PER_DEGREE = T.let(T.unsafe(nil), Float)

module RGeo::ImplHelper::Utils
  class << self
    def stringize_hash(hash_); end
    def symbolize_hash(hash_); end
  end
end

RGeo::VERSION = T.let(T.unsafe(nil), String)

module RGeo::WKRep
end

class RGeo::WKRep::WKBGenerator
  def initialize(opts_ = T.unsafe(nil)); end

  def _emit_byte(value_); end
  def _emit_doubles(array_); end
  def _emit_integer(value_); end
  def _emit_line_string_coords(obj_); end
  def _finish_emitter; end
  def _generate_feature(obj_, toplevel_ = T.unsafe(nil)); end
  def _point_coords(obj_, array_ = T.unsafe(nil)); end
  def _properties; end
  def _start_emitter; end
  def emit_ewkb_srid?; end
  def generate(obj_); end
  def hex_format?; end
  def little_endian?; end
  def type_format; end
end

RGeo::WKRep::WKBGenerator::TYPE_CODES = T.let(T.unsafe(nil), Hash)

class RGeo::WKRep::WKBParser
  def initialize(factory_generator_ = T.unsafe(nil), opts_ = T.unsafe(nil)); end

  def _bytes_remaining; end
  def _clean_scanner; end
  def _get_byte; end
  def _get_doubles(little_endian_, count_); end
  def _get_integer(little_endian_); end
  def _parse_line_string(little_endian_); end
  def _parse_object(contained_); end
  def _properties; end
  def _start_scanner(data_); end
  def exact_factory; end
  def factory_generator; end
  def ignore_extra_bytes?; end
  def parse(data_); end
  def parse_hex(data_); end
  def support_ewkb?; end
  def support_wkb12?; end
end

class RGeo::WKRep::WKTGenerator
  def initialize(opts_ = T.unsafe(nil)); end

  def _generate_coords(obj_); end
  def _generate_feature(obj_, toplevel_ = T.unsafe(nil)); end
  def _generate_geometry_collection(obj_); end
  def _generate_line_string(obj_); end
  def _generate_multi_line_string(obj_); end
  def _generate_multi_point(obj_); end
  def _generate_multi_polygon(obj_); end
  def _generate_point(obj_); end
  def _generate_polygon(obj_); end
  def _properties; end
  def convert_case; end
  def emit_ewkt_srid?; end
  def generate(obj_); end
  def square_brackets?; end
  def tag_format; end
  def type_format; end
end

class RGeo::WKRep::WKTParser
  def initialize(factory_generator_ = T.unsafe(nil), opts_ = T.unsafe(nil)); end

  def _check_factory_support; end
  def _clean_scanner; end
  def _ensure_factory; end
  def _expect_token_type(type_); end
  def _next_token; end
  def _parse_coords; end
  def _parse_geometry_collection; end
  def _parse_line_string; end
  def _parse_multi_line_string; end
  def _parse_multi_point; end
  def _parse_multi_polygon; end
  def _parse_point(convert_empty_ = T.unsafe(nil)); end
  def _parse_polygon; end
  def _parse_type_tag(_contained_); end
  def _properties; end
  def _start_scanner(str_); end
  def exact_factory; end
  def factory_generator; end
  def ignore_extra_tokens?; end
  def parse(str_); end
  def strict_wkt11?; end
  def support_ewkt?; end
  def support_wkt12?; end
end

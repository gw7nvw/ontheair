# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `roo` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Roo
  class << self
    def const_missing(const_name); end
  end
end

class Roo::Base
  include(::Enumerable)
  include(::Roo::Formatters::Base)
  include(::Roo::Formatters::CSV)
  include(::Roo::Formatters::Matrix)
  include(::Roo::Formatters::XML)
  include(::Roo::Formatters::YAML)

  def initialize(filename, options = T.unsafe(nil), _file_warning = T.unsafe(nil), _tmpdir = T.unsafe(nil)); end

  def cell_type_by_value(value); end
  def close; end
  def collect_last_row_col_for_sheet(sheet); end
  def column(column_number, sheet = T.unsafe(nil)); end
  def default_sheet; end
  def default_sheet=(sheet); end
  def each(options = T.unsafe(nil)); end
  def each_with_pagename; end
  def empty?(row, col, sheet = T.unsafe(nil)); end
  def find(*args); end
  def first_column(sheet = T.unsafe(nil)); end
  def first_column_as_letter(sheet = T.unsafe(nil)); end
  def first_last_row_col_for_sheet(sheet); end
  def first_row(sheet = T.unsafe(nil)); end
  def header_line; end
  def header_line=(_); end
  def headers; end
  def info; end
  def inspect; end
  def last_column(sheet = T.unsafe(nil)); end
  def last_column_as_letter(sheet = T.unsafe(nil)); end
  def last_row(sheet = T.unsafe(nil)); end
  def method_missing(m, *args); end
  def parse(options = T.unsafe(nil)); end
  def reload; end
  def row(row_number, sheet = T.unsafe(nil)); end
  def row_with(query, return_headers = T.unsafe(nil)); end
  def set(row, col, value, sheet = T.unsafe(nil)); end
  def sheet(index, name = T.unsafe(nil)); end

  protected

  def file_type_check(filename, exts, name, warning_level, packed = T.unsafe(nil)); end
  def is_stream?(filename_or_stream); end
  def key_to_num(str); end
  def key_to_string(arr); end

  private

  def clean_sheet(sheet); end
  def clean_sheet_if_need(options); end
  def download_uri(uri, tmpdir); end
  def file_type_warning_message(filename, exts); end
  def find_basename(filename); end
  def find_by_conditions(options); end
  def find_by_row(row_index); end
  def header_index(query); end
  def local_filename(filename, tmpdir, packed); end
  def make_tmpdir(prefix = T.unsafe(nil), root = T.unsafe(nil), &block); end
  def normalize(row, col); end
  def open_from_stream(stream, tmpdir); end
  def process_zipfile_packed(zip, tmpdir, path = T.unsafe(nil)); end
  def reinitialize; end
  def sanitize_value(v); end
  def search_or_set_header(options); end
  def set_headers(hash = T.unsafe(nil)); end
  def set_type(row, col, type, sheet = T.unsafe(nil)); end
  def set_value(row, col, value, sheet = T.unsafe(nil)); end
  def unzip(filename, tmpdir); end
  def uri?(filename); end
  def validate_sheet!(sheet); end
  def without_changing_default_sheet; end

  class << self
    def TEMP_PREFIX; end
    def finalize(object_id); end
  end
end

Roo::Base::MAX_ROW_COL = T.let(T.unsafe(nil), Fixnum)

Roo::Base::MIN_ROW_COL = T.let(T.unsafe(nil), Fixnum)

Roo::CLASS_FOR_EXTENSION = T.let(T.unsafe(nil), Hash)

class Roo::CSV < ::Roo::Base
  def cell(row, col, sheet = T.unsafe(nil)); end
  def cell_postprocessing(_row, _col, value); end
  def celltype(row, col, sheet = T.unsafe(nil)); end
  def csv_options; end
  def filename; end
  def filename_or_stream; end
  def set_type(row, col, type, _sheet); end
  def set_value(row, col, value, _sheet); end
  def sheets; end

  private

  def celltype_class(value); end
  def clean_sheet(sheet); end
  def each_row(options, &block); end
  def each_row_using_tempdir(options, &block); end
  def read_cells(sheet = T.unsafe(nil)); end
  def set_column_count(sheet, last_col); end
  def set_row_count(sheet, last_row); end
end

Roo::CSV::TYPE_MAP = T.let(T.unsafe(nil), Hash)

class Roo::Error < ::StandardError
end

class Roo::Excelx < ::Roo::Base
  extend(::Roo::Tempdir)
  extend(::Forwardable)

  def initialize(filename_or_stream, options = T.unsafe(nil)); end

  def cell(row, col, sheet = T.unsafe(nil)); end
  def celltype(row, col, sheet = T.unsafe(nil)); end
  def column(column_number, sheet = T.unsafe(nil)); end
  def comment(row, col, sheet = T.unsafe(nil)); end
  def comment?(row, col, sheet = T.unsafe(nil)); end
  def comments(sheet = T.unsafe(nil)); end
  def comments_files(*args, &block); end
  def each_row_streaming(options = T.unsafe(nil)); end
  def empty?(row, col, sheet = T.unsafe(nil)); end
  def excelx_format(row, col, sheet = T.unsafe(nil)); end
  def excelx_type(row, col, sheet = T.unsafe(nil)); end
  def excelx_value(row, col, sheet = T.unsafe(nil)); end
  def first_column(sheet = T.unsafe(nil)); end
  def first_row(sheet = T.unsafe(nil)); end
  def font(row, col, sheet = T.unsafe(nil)); end
  def formatted_value(row, col, sheet = T.unsafe(nil)); end
  def formula(row, col, sheet = T.unsafe(nil)); end
  def formula?(*args); end
  def formulas(sheet = T.unsafe(nil)); end
  def hyperlink(row, col, sheet = T.unsafe(nil)); end
  def hyperlink?(row, col, sheet = T.unsafe(nil)); end
  def image_files(*args, &block); end
  def image_rels(*args, &block); end
  def images(sheet = T.unsafe(nil)); end
  def label(name); end
  def labels; end
  def last_column(sheet = T.unsafe(nil)); end
  def last_row(sheet = T.unsafe(nil)); end
  def method_missing(method, *args); end
  def rels_files(*args, &block); end
  def row(rownumber, sheet = T.unsafe(nil)); end
  def set(row, col, value, sheet = T.unsafe(nil)); end
  def shared_strings(*args, &block); end
  def sheet_files(*args, &block); end
  def sheet_for(sheet); end
  def sheets; end
  def styles(*args, &block); end
  def to_s(sheet = T.unsafe(nil)); end
  def workbook(*args, &block); end

  private

  def clean_sheet(sheet); end
  def extract_images(entries, tmpdir); end
  def extract_sheets_in_order(entries, sheet_ids, sheets, tmpdir); end
  def extract_worksheet_ids(entries, path); end
  def extract_worksheet_rels(entries, path); end
  def process_zipfile(zipfilename_or_stream); end
  def process_zipfile_entries(entries); end
  def safe_send(object, method, *args); end
  def worksheet_types; end
end

class Roo::Excelx::Cell
  def initialize(value, type, formula, excelx_type, excelx_value, style, hyperlink, base_date, coordinate); end

  def coordinate; end
  def excelx_type; end
  def excelx_value; end
  def formula; end
  def hyperlink; end
  def style; end
  def type; end
  def value; end
  def value=(_); end

  private

  def create_date(date); end
  def create_datetime(date); end
  def round_datetime(datetime_string); end
  def type_cast_value(value); end

  class << self
    def cell_class(type); end
    def create_cell(type, *values); end
  end
end

class Roo::Excelx::Cell::Base
  extend(::Roo::Helpers::DefaultAttrReader)

  def initialize(value, formula, excelx_type, style, link, coordinate); end

  def cell_type; end
  def cell_value; end
  def default_type; end
  def empty?; end
  def excelx_type; end
  def excelx_value; end
  def formatted_value; end
  def formula?; end
  def hyperlink; end
  def link; end
  def link?; end
  def presence; end
  def style; end
  def to_s; end
  def type; end
  def value; end
  def value=(_); end
end

class Roo::Excelx::Cell::Boolean < ::Roo::Excelx::Cell::Base
  def initialize(value, formula, style, link, coordinate); end

  def cell_type; end
  def cell_value; end
  def coordinate; end
  def default_type; end
  def format; end
  def formatted_value; end
  def formula; end
  def value; end

  private

  def create_boolean(value); end
end

class Roo::Excelx::Cell::Coordinate
  def initialize(row, column); end

  def column; end
  def column=(_); end
  def row; end
  def row=(_); end
end

class Roo::Excelx::Cell::Date < ::Roo::Excelx::Cell::DateTime
  def initialize(value, formula, excelx_type, style, link, base_date, coordinate); end

  def cell_type; end
  def cell_value; end
  def coordinate; end
  def default_type; end
  def format; end
  def formula; end
  def value; end

  private

  def create_date(base_date, value); end
  def create_datetime(_, _); end
end

class Roo::Excelx::Cell::DateTime < ::Roo::Excelx::Cell::Base
  def initialize(value, formula, excelx_type, style, link, base_timestamp, coordinate); end

  def cell_value; end
  def coordinate; end
  def default_type; end
  def format; end
  def formatted_value; end
  def formula; end
  def value; end

  private

  def create_datetime(base_timestamp, value); end
  def parse_date_or_time_format(part); end
end

Roo::Excelx::Cell::DateTime::DATE_FORMATS = T.let(T.unsafe(nil), Hash)

Roo::Excelx::Cell::DateTime::SECONDS_IN_DAY = T.let(T.unsafe(nil), Fixnum)

Roo::Excelx::Cell::DateTime::TIME_FORMATS = T.let(T.unsafe(nil), Hash)

class Roo::Excelx::Cell::Empty < ::Roo::Excelx::Cell::Base
  def initialize(coordinate); end

  def cell_type; end
  def cell_value; end
  def coordinate; end
  def default_type; end
  def empty?; end
  def format; end
  def formula; end
  def style; end
  def value; end
end

class Roo::Excelx::Cell::Number < ::Roo::Excelx::Cell::Base
  def initialize(value, formula, excelx_type, style, link, coordinate); end

  def cell_value; end
  def coordinate; end
  def create_numeric(number); end
  def default_type; end
  def format; end
  def formatted_value; end
  def formula; end
  def generate_formatter(format); end
  def value; end

  private

  def number_format(formatter, negative_formatter = T.unsafe(nil)); end
end

class Roo::Excelx::Cell::String < ::Roo::Excelx::Cell::Base
  def initialize(value, formula, style, link, coordinate); end

  def cell_type; end
  def cell_value; end
  def coordinate; end
  def default_type; end
  def empty?; end
  def format; end
  def formula; end
  def value; end
end

class Roo::Excelx::Cell::Time < ::Roo::Excelx::Cell::DateTime
  def initialize(value, formula, excelx_type, style, link, base_date, coordinate); end

  def cell_value; end
  def coordinate; end
  def default_type; end
  def format; end
  def formatted_value; end
  def formula; end
  def to_s; end
  def value; end
end

class Roo::Excelx::Comments < ::Roo::Excelx::Extractor
  def comments; end

  private

  def extract_comments; end
end

class Roo::Excelx::Coordinate < ::Array
  def initialize(row, column); end

  def column; end
  def row; end
end

Roo::Excelx::ERROR_VALUES = T.let(T.unsafe(nil), Set)

class Roo::Excelx::ExceedsMaxError < ::StandardError
end

class Roo::Excelx::Extractor
  include(::Roo::Helpers::WeakInstanceCache)

  def initialize(path, options = T.unsafe(nil)); end


  private

  def doc; end
  def doc_exists?; end
end

Roo::Excelx::Extractor::COMMON_STRINGS = T.let(T.unsafe(nil), Hash)

module Roo::Excelx::Format
  extend(::Roo::Excelx::Format)

  def _to_type(format); end
  def to_type(format); end
end

Roo::Excelx::Format::EXCEPTIONAL_FORMATS = T.let(T.unsafe(nil), Hash)

Roo::Excelx::Format::STANDARD_FORMATS = T.let(T.unsafe(nil), Hash)

class Roo::Excelx::Images < ::Roo::Excelx::Extractor
  def list; end

  private

  def extract_images_names; end
end

class Roo::Excelx::Relationships < ::Roo::Excelx::Extractor
  def [](index); end
  def include_type?(type); end
  def to_a; end

  private

  def extract_relationships; end
end

class Roo::Excelx::Shared
  def initialize(dir, options = T.unsafe(nil)); end

  def base_date; end
  def base_timestamp; end
  def comments_files; end
  def comments_files=(_); end
  def image_files; end
  def image_files=(_); end
  def image_rels; end
  def image_rels=(_); end
  def rels_files; end
  def rels_files=(_); end
  def shared_strings; end
  def sheet_files; end
  def sheet_files=(_); end
  def styles; end
  def workbook; end
end

class Roo::Excelx::SharedStrings < ::Roo::Excelx::Extractor
  def [](index); end
  def to_a; end
  def to_html; end
  def use_html?(index); end

  private

  def create_html(text, formatting); end
  def extract_html; end
  def extract_html_r(r_elem); end
  def extract_shared_strings; end
  def fix_invalid_shared_strings(doc); end
end

class Roo::Excelx::Sheet
  extend(::Forwardable)

  def initialize(name, shared, sheet_index, options = T.unsafe(nil)); end

  def cells; end
  def column(col_number); end
  def comments; end
  def comments_files(*args, &block); end
  def dimensions; end
  def each_row(options = T.unsafe(nil), &block); end
  def excelx_format(key); end
  def first_column; end
  def first_row; end
  def hyperlinks; end
  def image_rels(*args, &block); end
  def images; end
  def last_column; end
  def last_row; end
  def present_cells; end
  def rels_files(*args, &block); end
  def row(row_number); end
  def shared_strings(*args, &block); end
  def sheet_files(*args, &block); end
  def styles(*args, &block); end
  def workbook(*args, &block); end

  private

  def cells_for_row_element(row_element, options = T.unsafe(nil)); end
  def first_last_row_col; end
  def pad_cells(cell, last_column); end
end

class Roo::Excelx::SheetDoc < ::Roo::Excelx::Extractor
  extend(::Forwardable)

  def initialize(path, relationships, shared, options = T.unsafe(nil)); end

  def cells(relationships); end
  def dimensions; end
  def each_cell(row_xml); end
  def each_row_streaming(&block); end
  def hyperlinks(relationships); end
  def workbook(*args, &block); end

  private

  def base_date; end
  def base_timestamp; end
  def cell_from_xml(cell_xml, hyperlink, coordinate, empty_cell = T.unsafe(nil)); end
  def cell_value_type(type, format); end
  def create_cell_from_value(value_type, cell, formula, format, style, hyperlink, coordinate); end
  def create_empty_cell(coordinate, empty_cell); end
  def expand_merged_ranges(cells); end
  def extract_cells(relationships); end
  def extract_dimensions; end
  def extract_hyperlinks(relationships); end
  def shared_strings; end
  def style_format(style); end
end

class Roo::Excelx::Styles < ::Roo::Excelx::Extractor
  def definitions; end
  def style_format(style); end

  private

  def extract_definitions; end
  def extract_fonts; end
  def extract_num_fmt_ids; end
  def extract_num_fmts; end
  def fonts; end
  def num_fmt_ids; end
  def num_fmts; end
end

class Roo::Excelx::Workbook < ::Roo::Excelx::Extractor
  def initialize(path); end

  def base_date; end
  def base_timestamp; end
  def defined_names; end
  def sheets; end
end

class Roo::Excelx::Workbook::Label
  def initialize(name, sheet, row, col); end

  def col; end
  def key; end
  def name; end
  def row; end
  def sheet; end
end

class Roo::FileNotFound < ::Roo::Error
end

class Roo::Font
  def bold; end
  def bold=(_); end
  def bold?; end
  def italic; end
  def italic=(_); end
  def italic?; end
  def underline; end
  def underline=(_); end
  def underline?; end
end

module Roo::Formatters
end

module Roo::Formatters::Base
  def integer_to_timestring(content); end
end

module Roo::Formatters::CSV
  def to_csv(filename = T.unsafe(nil), separator = T.unsafe(nil), sheet = T.unsafe(nil)); end

  private

  def cell_to_csv(row, col, sheet); end
  def write_csv_content(file = T.unsafe(nil), sheet = T.unsafe(nil), separator = T.unsafe(nil)); end
end

module Roo::Formatters::Matrix
  def to_matrix(from_row = T.unsafe(nil), from_column = T.unsafe(nil), to_row = T.unsafe(nil), to_column = T.unsafe(nil), sheet = T.unsafe(nil)); end
end

module Roo::Formatters::XML
  def to_xml; end
end

module Roo::Formatters::YAML
  def to_yaml(prefix = T.unsafe(nil), from_row = T.unsafe(nil), from_column = T.unsafe(nil), to_row = T.unsafe(nil), to_column = T.unsafe(nil), sheet = T.unsafe(nil)); end
end

class Roo::HeaderRowNotFoundError < ::Roo::Error
end

module Roo::Helpers
end

module Roo::Helpers::DefaultAttrReader
  def attr_reader_with_default(attr_hash); end
end

module Roo::Helpers::WeakInstanceCache

  private

  def instance_cache(key); end
  def instance_cache_finalizer(key); end
end

Roo::LibreOffice = Roo::OpenOffice

class Roo::Link < ::String
  def initialize(href = T.unsafe(nil), text = T.unsafe(nil)); end

  def href; end
  def to_uri; end
  def url; end
end

class Roo::OpenOffice < ::Roo::Base
  extend(::Roo::Tempdir)

  def initialize(filename, options = T.unsafe(nil)); end

  def cell(row, col, sheet = T.unsafe(nil)); end
  def celltype(row, col, sheet = T.unsafe(nil)); end
  def comment(row, col, sheet = T.unsafe(nil)); end
  def comments(sheet = T.unsafe(nil)); end
  def font(row, col, sheet = T.unsafe(nil)); end
  def formula(row, col, sheet = T.unsafe(nil)); end
  def formula?(*args); end
  def formulas(sheet = T.unsafe(nil)); end
  def initialize_default_variables; end
  def label(labelname); end
  def labels(_sheet = T.unsafe(nil)); end
  def method_missing(m, *args); end
  def officeversion; end
  def open_oo_file(options); end
  def sheets; end
  def to_s(sheet = T.unsafe(nil)); end

  private

  def attribute(node, attr_name); end
  def children_to_string(children); end
  def decrypt(content_entry, cipher); end
  def decrypt_if_necessary(zip_file, content_entry, roo_content_xml_path, options); end
  def doc; end
  def find_cipher(*args); end
  def find_cipher_key(*args); end
  def oo_version; end
  def perform_decryption(encryption_data, password, content_entry, roo_content_xml_path); end
  def read_cells(sheet = T.unsafe(nil)); end
  def read_comments(sheet = T.unsafe(nil)); end
  def read_labels; end
  def read_styles(style_elements); end
  def read_table_styles(styles); end
  def set_cell_values(sheet, x, y, i, v, value_type, formula, table_cell, str_v, style_name); end
end

Roo::OpenOffice::ERROR_MISSING_CONTENT_XML = T.let(T.unsafe(nil), String)

Roo::OpenOffice::XPATH_FIND_TABLE_STYLES = T.let(T.unsafe(nil), String)

Roo::OpenOffice::XPATH_LOCAL_NAME_TABLE = T.let(T.unsafe(nil), String)

Roo::ROO_EXCELML_NOTICE = T.let(T.unsafe(nil), String)

Roo::ROO_EXCEL_NOTICE = T.let(T.unsafe(nil), String)

Roo::ROO_GOOGLE_NOTICE = T.let(T.unsafe(nil), String)

class Roo::Spreadsheet
  class << self
    def extension_for(path, options); end
    def open(path, options = T.unsafe(nil)); end
  end
end

Roo::TEMP_PREFIX = T.let(T.unsafe(nil), String)

module Roo::Tempdir
  def finalize_tempdirs(object_id); end
  def make_tempdir(object, prefix, root); end
end

module Roo::Utils
  extend(::Roo::Utils)

  def coordinates_in_range(str); end
  def each_element(path, elements); end
  def extract_coordinate(s); end
  def letter_to_number(letters); end
  def load_xml(path); end
  def num_cells_in_range(str); end
  def number_to_letter(num); end
  def ref_to_key(s); end
  def split_coord(str); end
  def split_coordinate(str); end

  private

  def char_index(byte); end
  def num_index(byte); end
end

Roo::Utils::LETTERS = T.let(T.unsafe(nil), Array)

Roo::VERSION = T.let(T.unsafe(nil), String)

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Rack
  class << self
    def release; end
    def version; end
  end
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm = T.unsafe(nil), &authenticator); end

  def realm; end
  def realm=(_); end

  private

  def bad_request; end
  def unauthorized(www_authenticate = T.unsafe(nil)); end
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params; end
  def parts; end
  def provided?; end
  def request; end
  def scheme; end

  private

  def authorization_key; end
end

Rack::Auth::AbstractRequest::AUTHORIZATION_KEYS = T.let(T.unsafe(nil), Array)

class Rack::Auth::Basic < ::Rack::Auth::AbstractHandler
  def call(env); end

  private

  def challenge; end
  def valid?(auth); end
end

class Rack::Auth::Basic::Request < ::Rack::Auth::AbstractRequest
  def basic?; end
  def credentials; end
  def username; end
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5 < ::Rack::Auth::AbstractHandler
  def initialize(app, realm = T.unsafe(nil), opaque = T.unsafe(nil), &authenticator); end

  def call(env); end
  def opaque; end
  def opaque=(_); end
  def passwords_hashed=(_); end
  def passwords_hashed?; end

  private

  def A1(auth, password); end
  def A2(auth); end
  def H(data); end
  def KD(secret, data); end
  def challenge(hash = T.unsafe(nil)); end
  def digest(auth, password); end
  def md5(data); end
  def params(hash = T.unsafe(nil)); end
  def valid?(auth); end
  def valid_digest?(auth); end
  def valid_nonce?(auth); end
  def valid_opaque?(auth); end
  def valid_qop?(auth); end
end

Rack::Auth::Digest::MD5::QOP = T.let(T.unsafe(nil), String)

class Rack::Auth::Digest::Nonce
  def initialize(timestamp = T.unsafe(nil), given_digest = T.unsafe(nil)); end

  def digest; end
  def fresh?; end
  def stale?; end
  def to_s; end
  def valid?; end

  class << self
    def parse(string); end
    def private_key; end
    def private_key=(_); end
    def time_limit; end
    def time_limit=(_); end
  end
end

class Rack::Auth::Digest::Params < ::Hash
  def initialize; end

  def [](k); end
  def []=(k, v); end
  def quote(str); end
  def to_s; end

  class << self
    def dequote(str); end
    def parse(str); end
    def split_header_value(str); end
  end
end

Rack::Auth::Digest::Params::UNQUOTED = T.let(T.unsafe(nil), Array)

class Rack::Auth::Digest::Request < ::Rack::Auth::AbstractRequest
  def correct_uri?; end
  def digest?; end
  def method; end
  def method_missing(sym, *args); end
  def nonce; end
  def params; end
  def respond_to?(sym, *_); end
end

class Rack::BodyProxy
  def initialize(body, &block); end

  def close; end
  def closed?; end
  def each(*args, &block); end
  def method_missing(*args, &block); end
  def respond_to?(*args); end
end

class Rack::Builder
  include(::Sinatra::Delegator)

  def initialize(default_app = T.unsafe(nil), &block); end

  def call(env); end
  def map(path, &block); end
  def run(app); end
  def to_app; end
  def use(middleware, *args, &block); end

  private

  def generate_map(default_app, mapping); end

  class << self
    def app(default_app = T.unsafe(nil), &block); end
    def new_from_string(builder_script, file = T.unsafe(nil)); end
    def parse_file(config, opts = T.unsafe(nil)); end
  end
end

class Rack::Cascade
  def initialize(apps, catch = T.unsafe(nil)); end

  def <<(app); end
  def add(app); end
  def apps; end
  def call(env); end
  def include?(app); end
end

Rack::Cascade::NotFound = T.let(T.unsafe(nil), Array)

class Rack::Chunked
  include(::Rack::Utils)

  def initialize(app); end

  def call(env); end
end

class Rack::Chunked::Body
  include(::Rack::Utils)

  def initialize(body); end

  def close; end
  def each; end
end

Rack::Chunked::Body::TAIL = T.let(T.unsafe(nil), String)

Rack::Chunked::Body::TERM = T.let(T.unsafe(nil), String)

class Rack::CommonLogger
  def initialize(app, logger = T.unsafe(nil)); end

  def call(env); end
  def call_without_check(env); end

  private

  def extract_content_length(headers); end
  def log(env, status, header, began_at); end
end

Rack::CommonLogger::FORMAT = T.let(T.unsafe(nil), String)

class Rack::ConditionalGet
  def initialize(app); end

  def call(env); end

  private

  def etag_matches?(none_match, headers); end
  def fresh?(env, headers); end
  def modified_since?(modified_since, headers); end
  def to_rfc2822(since); end
end

class Rack::Config
  def initialize(app, &block); end

  def call(env); end
end

class Rack::ContentLength
  include(::Rack::Utils)

  def initialize(app); end

  def call(env); end
end

class Rack::ContentType
  include(::Rack::Utils)

  def initialize(app, content_type = T.unsafe(nil)); end

  def call(env); end
end

class Rack::Deflater
  def initialize(app); end

  def call(env); end
end

class Rack::Deflater::DeflateStream
  def initialize(body); end

  def each; end
end

Rack::Deflater::DeflateStream::DEFLATE_ARGS = T.let(T.unsafe(nil), Array)

class Rack::Deflater::GzipStream
  def initialize(body, mtime); end

  def each(&block); end
  def write(data); end
end

class Rack::Directory
  def initialize(root, app = T.unsafe(nil)); end

  def _call(env); end
  def call(env); end
  def check_forbidden; end
  def each; end
  def entity_not_found; end
  def files; end
  def filesize_format(int); end
  def list_directory; end
  def list_path; end
  def path; end
  def path=(_); end
  def root; end
  def root=(_); end
  def stat(node, max = T.unsafe(nil)); end
end

Rack::Directory::DIR_FILE = T.let(T.unsafe(nil), String)

Rack::Directory::DIR_PAGE = T.let(T.unsafe(nil), String)

Rack::Directory::F = File

Rack::Directory::FILESIZE_FORMAT = T.let(T.unsafe(nil), Array)

class Rack::ETag
  def initialize(app, no_cache_control = T.unsafe(nil), cache_control = T.unsafe(nil)); end

  def call(env); end

  private

  def digest_body(body); end
  def etag_body?(body); end
  def etag_status?(status); end
  def skip_caching?(headers); end
end

Rack::ETag::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

class Rack::File
  def initialize(root, headers = T.unsafe(nil), default_mime = T.unsafe(nil)); end

  def _call(env); end
  def cache_control; end
  def cache_control=(_); end
  def call(env); end
  def each; end
  def path; end
  def path=(_); end
  def root; end
  def root=(_); end
  def serving(env); end
  def to_path; end

  private

  def fail(status, body); end
end

Rack::File::ALLOWED_VERBS = T.let(T.unsafe(nil), Array)

Rack::File::F = File

Rack::File::SEPS = T.let(T.unsafe(nil), Regexp)

class Rack::ForwardRequest < ::Exception
  def initialize(url, env = T.unsafe(nil)); end

  def env; end
  def url; end
end

module Rack::Handler
  class << self
    def default(options = T.unsafe(nil)); end
    def get(server); end
    def pick(server_names); end
    def register(server, klass); end
    def try_require(prefix, const_name); end
  end
end

class Rack::Handler::CGI
  class << self
    def run(app, options = T.unsafe(nil)); end
    def send_body(body); end
    def send_headers(status, headers); end
    def serve(app); end
  end
end

class Rack::Handler::WEBrick < ::WEBrick::HTTPServlet::AbstractServlet
  def initialize(server, app); end

  def service(req, res); end

  class << self
    def run(app, options = T.unsafe(nil)); end
    def shutdown; end
    def valid_options; end
  end
end

class Rack::Head
  def initialize(app); end

  def call(env); end
end

class Rack::Lint
  include(::Rack::Lint::Assertion)

  def initialize(app); end

  def _call(env); end
  def call(env = T.unsafe(nil)); end
  def check_content_length(status, headers); end
  def check_content_type(status, headers); end
  def check_env(env); end
  def check_error(error); end
  def check_headers(header); end
  def check_hijack(env); end
  def check_hijack_response(headers, env); end
  def check_input(input); end
  def check_status(status); end
  def close; end
  def each; end
  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message, &block); end
end

class Rack::Lint::ErrorWrapper
  include(::Rack::Lint::Assertion)

  def initialize(error); end

  def close(*args); end
  def flush; end
  def puts(str); end
  def write(str); end
end

class Rack::Lint::HijackWrapper
  include(::Rack::Lint::Assertion)
  extend(::Forwardable)

  def initialize(io); end

  def close(*args, &block); end
  def close_read(*args, &block); end
  def close_write(*args, &block); end
  def closed?(*args, &block); end
  def flush(*args, &block); end
  def read(*args, &block); end
  def read_nonblock(*args, &block); end
  def write(*args, &block); end
  def write_nonblock(*args, &block); end
end

Rack::Lint::HijackWrapper::REQUIRED_METHODS = T.let(T.unsafe(nil), Array)

class Rack::Lint::InputWrapper
  include(::Rack::Lint::Assertion)

  def initialize(input); end

  def close(*args); end
  def each(*args); end
  def gets(*args); end
  def read(*args); end
  def rewind(*args); end
end

class Rack::Lint::LintError < ::RuntimeError
end

class Rack::Lock
  def initialize(app, mutex = T.unsafe(nil)); end

  def call(env); end
end

Rack::Lock::FLAG = T.let(T.unsafe(nil), String)

class Rack::Logger
  def initialize(app, level = T.unsafe(nil)); end

  def call(env); end
end

class Rack::MethodOverride
  def initialize(app); end

  def call(env); end
  def method_override(env); end
end

Rack::MethodOverride::HTTP_METHODS = T.let(T.unsafe(nil), Array)

Rack::MethodOverride::HTTP_METHOD_OVERRIDE_HEADER = T.let(T.unsafe(nil), String)

Rack::MethodOverride::METHOD_OVERRIDE_PARAM_KEY = T.let(T.unsafe(nil), String)

module Rack::Mime

  private

  def match?(value, matcher); end
  def mime_type(ext, fallback = T.unsafe(nil)); end

  class << self
    def match?(value, matcher); end
    def mime_type(ext, fallback = T.unsafe(nil)); end
  end
end

Rack::Mime::MIME_TYPES = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest
  def initialize(app); end

  def delete(uri, opts = T.unsafe(nil)); end
  def get(uri, opts = T.unsafe(nil)); end
  def head(uri, opts = T.unsafe(nil)); end
  def patch(uri, opts = T.unsafe(nil)); end
  def post(uri, opts = T.unsafe(nil)); end
  def put(uri, opts = T.unsafe(nil)); end
  def request(method = T.unsafe(nil), uri = T.unsafe(nil), opts = T.unsafe(nil)); end

  class << self
    def env_for(uri = T.unsafe(nil), opts = T.unsafe(nil)); end
  end
end

Rack::MockRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class Rack::MockRequest::FatalWarner
  def flush; end
  def puts(warning); end
  def string; end
  def write(warning); end
end

class Rack::MockRequest::FatalWarning < ::RuntimeError
end

class Rack::MockResponse < ::Rack::Response
  def initialize(status, headers, body, errors = T.unsafe(nil)); end

  def =~(other); end
  def body; end
  def empty?; end
  def errors; end
  def errors=(_); end
  def match(other); end
  def original_headers; end
end

module Rack::Multipart
  class << self
    def build_multipart(params, first = T.unsafe(nil)); end
    def parse_multipart(env); end
  end
end

Rack::Multipart::BROKEN_QUOTED = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::BROKEN_UNQUOTED = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::CONDISP = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::DISPPARM = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::EOL = T.let(T.unsafe(nil), String)

class Rack::Multipart::Generator
  def initialize(params, first = T.unsafe(nil)); end

  def dump; end

  private

  def content_for_other(file, name); end
  def content_for_tempfile(io, file, name); end
  def flattened_params; end
  def multipart?; end
end

Rack::Multipart::MULTIPART = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::MULTIPART_BOUNDARY = T.let(T.unsafe(nil), String)

Rack::Multipart::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::Parser
  def initialize(env); end

  def parse; end

  private

  def fast_forward_to_first_boundary; end
  def full_boundary; end
  def get_current_head_and_filename_and_content_type_and_name_and_body; end
  def get_data(filename, body, content_type, name, head); end
  def get_filename(head); end
  def rx; end
  def setup_parse; end
end

Rack::Multipart::Parser::BUFSIZE = T.let(T.unsafe(nil), Fixnum)

Rack::Multipart::RFC2183 = T.let(T.unsafe(nil), Regexp)

Rack::Multipart::TOKEN = T.let(T.unsafe(nil), Regexp)

class Rack::Multipart::UploadedFile
  def initialize(path, content_type = T.unsafe(nil), binary = T.unsafe(nil)); end

  def content_type; end
  def content_type=(_); end
  def local_path; end
  def method_missing(method_name, *args, &block); end
  def original_filename; end
  def path; end
  def respond_to?(*args); end
end

class Rack::NullLogger
  def initialize(app); end

  def call(env); end
  def debug(progname = T.unsafe(nil), &block); end
  def error(progname = T.unsafe(nil), &block); end
  def fatal(progname = T.unsafe(nil), &block); end
  def info(progname = T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), &block); end
end

class Rack::Recursive
  def initialize(app); end

  def _call(env); end
  def call(env); end
  def include(env, path); end
end

class Rack::Reloader
  def initialize(app, cooldown = T.unsafe(nil), backend = T.unsafe(nil)); end

  def call(env); end
  def reload!(stderr = T.unsafe(nil)); end
  def safe_load(file, mtime, stderr = T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end
  def rotation; end
  def safe_stat(file); end
end

class Rack::Request
  def initialize(env); end

  def GET; end
  def POST; end
  def [](key); end
  def []=(key, value); end
  def accept_encoding; end
  def base_url; end
  def body; end
  def content_charset; end
  def content_length; end
  def content_type; end
  def cookies; end
  def delete?; end
  def delete_param(k); end
  def env; end
  def form_data?; end
  def fullpath; end
  def get?; end
  def head?; end
  def host; end
  def host_with_port; end
  def ip; end
  def logger; end
  def media_type; end
  def media_type_params; end
  def options?; end
  def params; end
  def parseable_data?; end
  def patch?; end
  def path; end
  def path_info; end
  def path_info=(s); end
  def port; end
  def post?; end
  def put?; end
  def query_string; end
  def referer; end
  def referrer; end
  def request_method; end
  def scheme; end
  def script_name; end
  def script_name=(s); end
  def session; end
  def session_options; end
  def ssl?; end
  def trace?; end
  def trusted_proxy?(ip); end
  def update_param(k, v); end
  def url; end
  def user_agent; end
  def values_at(*keys); end
  def xhr?; end

  protected

  def parse_multipart(env); end
  def parse_query(qs); end
  def reject_trusted_ip_addresses(ip_addresses); end
  def split_ip_addresses(ip_addresses); end
end

Rack::Request::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

Rack::Request::FORM_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

Rack::Request::PARSEABLE_DATA_MEDIA_TYPES = T.let(T.unsafe(nil), Array)

class Rack::Response
  include(::Rack::Response::Helpers)

  def initialize(body = T.unsafe(nil), status = T.unsafe(nil), header = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def body; end
  def body=(_); end
  def close; end
  def delete_cookie(key, value = T.unsafe(nil)); end
  def each(&callback); end
  def empty?; end
  def finish(&block); end
  def header; end
  def headers; end
  def length; end
  def length=(_); end
  def redirect(target, status = T.unsafe(nil)); end
  def set_cookie(key, value); end
  def status; end
  def status=(_); end
  def to_a(&block); end
  def to_ary(&block); end
  def write(str); end
end

module Rack::Response::Helpers
  def bad_request?; end
  def client_error?; end
  def content_length; end
  def content_type; end
  def forbidden?; end
  def headers; end
  def include?(header); end
  def informational?; end
  def invalid?; end
  def location; end
  def method_not_allowed?; end
  def not_found?; end
  def ok?; end
  def original_headers; end
  def redirect?; end
  def redirection?; end
  def server_error?; end
  def successful?; end
  def unprocessable?; end
end

class Rack::Runtime
  def initialize(app, name = T.unsafe(nil)); end

  def call(env); end
end

class Rack::Sendfile
  def initialize(app, variation = T.unsafe(nil), mappings = T.unsafe(nil)); end

  def call(env); end

  private

  def map_accel_path(env, path); end
  def variation(env); end
end

Rack::Sendfile::F = File

class Rack::Server
  def initialize(options = T.unsafe(nil)); end

  def app; end
  def default_options; end
  def middleware; end
  def options; end
  def options=(_); end
  def server; end
  def start(&blk); end

  private

  def build_app(app); end
  def build_app_and_options_from_config; end
  def build_app_from_string; end
  def check_pid!; end
  def daemonize_app; end
  def opt_parser; end
  def parse_options(args); end
  def pidfile_process_status; end
  def wrapped_app; end
  def write_pid; end

  class << self
    def logging_middleware; end
    def middleware; end
    def start(options = T.unsafe(nil)); end
  end
end

class Rack::Server::Options
  def handler_opts(options); end
  def parse!(args); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

Rack::Session::Abstract::ENV_SESSION_KEY = T.let(T.unsafe(nil), String)

Rack::Session::Abstract::ENV_SESSION_OPTIONS_KEY = T.let(T.unsafe(nil), String)

class Rack::Session::Abstract::ID
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end
  def context(env, app = T.unsafe(nil)); end
  def default_options; end
  def key; end

  private

  def commit_session(env, status, headers, body); end
  def commit_session?(env, session, options); end
  def current_session_id(env); end
  def destroy_session(env, sid, options); end
  def extract_session_id(env); end
  def force_options?(options); end
  def forced_session_update?(session, options); end
  def generate_sid(secure = T.unsafe(nil)); end
  def get_session(env, sid); end
  def initialize_sid; end
  def load_session(env); end
  def loaded_session?(session); end
  def prepare_session(env); end
  def security_matches?(env, options); end
  def session_class; end
  def session_exists?(env); end
  def set_cookie(env, headers, cookie); end
  def set_session(env, sid, session, options); end
end

Rack::Session::Abstract::ID::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::Session::Abstract::SessionHash
  include(::Enumerable)

  def initialize(store, env); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def destroy; end
  def each(&block); end
  def empty?; end
  def exists?; end
  def fetch(key); end
  def has_key?(key); end
  def id; end
  def id=(_); end
  def include?(key); end
  def inspect; end
  def key?(key); end
  def keys; end
  def loaded?; end
  def merge!(hash); end
  def options; end
  def replace(hash); end
  def store(key, value); end
  def to_hash; end
  def update(hash); end
  def values; end

  private

  def load!; end
  def load_for_read!; end
  def load_for_write!; end
  def stringify_keys(other); end

  class << self
    def find(env); end
    def set(env, session); end
    def set_options(env, options); end
  end
end

class Rack::Session::Cookie < ::Rack::Session::Abstract::ID
  def initialize(app, options = T.unsafe(nil)); end

  def coder; end

  private

  def destroy_session(env, session_id, options); end
  def digest_match?(data, digest); end
  def extract_session_id(env); end
  def generate_hmac(data, secret); end
  def get_session(env, sid); end
  def persistent_session_id!(data, sid = T.unsafe(nil)); end
  def set_session(env, session_id, session, options); end
  def unpacked_cookie_data(env); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::Marshal < ::Rack::Session::Cookie::Base64
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::Identity
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Cookie::Reverse
  def decode(str); end
  def encode(str); end
end

class Rack::Session::Pool < ::Rack::Session::Abstract::ID
  def initialize(app, options = T.unsafe(nil)); end

  def destroy_session(env, session_id, options); end
  def generate_sid; end
  def get_session(env, sid); end
  def mutex; end
  def pool; end
  def set_session(env, session_id, new_session, options); end
  def with_lock(env, default = T.unsafe(nil)); end
end

Rack::Session::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Rack::ShowExceptions
  def initialize(app); end

  def call(env); end
  def dump_exception(exception); end
  def h(obj); end
  def prefers_plain_text?(env); end
  def pretty(env, exception); end
end

Rack::ShowExceptions::CONTEXT = T.let(T.unsafe(nil), Fixnum)

Rack::ShowExceptions::TEMPLATE = T.let(T.unsafe(nil), String)

class Rack::ShowStatus
  def initialize(app); end

  def call(env); end
  def h(obj); end
end

Rack::ShowStatus::TEMPLATE = T.let(T.unsafe(nil), String)

class Rack::Static
  def initialize(app, options = T.unsafe(nil)); end

  def apply_header_rules; end
  def apply_rule(rule, headers); end
  def call(env); end
  def can_serve(path); end
  def overwrite_file_path(path); end
  def route_file(path); end
  def set_headers(headers); end
end

class Rack::URLMap
  def initialize(map = T.unsafe(nil)); end

  def call(env); end
  def remap(map); end
end

Rack::URLMap::INFINITY = T.let(T.unsafe(nil), Float)

Rack::URLMap::NEGATIVE_INFINITY = T.let(T.unsafe(nil), Float)

module Rack::Utils

  private

  def best_q_match(q_value_header, available_mimes); end
  def build_nested_query(value, prefix = T.unsafe(nil)); end
  def build_query(params); end
  def byte_ranges(env, size); end
  def bytesize(string); end
  def delete_cookie_header!(header, key, value = T.unsafe(nil)); end
  def escape(s); end
  def escape_html(string); end
  def escape_path(s); end
  def normalize_params(params, name, v = T.unsafe(nil), depth = T.unsafe(nil)); end
  def params_hash_type?(obj); end
  def parse_nested_query(qs, d = T.unsafe(nil)); end
  def parse_query(qs, d = T.unsafe(nil), &unescaper); end
  def q_values(q_value_header); end
  def rfc2109(time); end
  def rfc2822(time); end
  def secure_compare(a, b); end
  def select_best_encoding(available_encodings, accept_encoding); end
  def set_cookie_header!(header, key, value); end
  def status_code(status); end
  def unescape(s, encoding = T.unsafe(nil)); end

  class << self
    def best_q_match(q_value_header, available_mimes); end
    def build_nested_query(value, prefix = T.unsafe(nil)); end
    def build_query(params); end
    def byte_ranges(env, size); end
    def bytesize(string); end
    def delete_cookie_header!(header, key, value = T.unsafe(nil)); end
    def escape(s); end
    def escape_html(string); end
    def escape_path(s); end
    def key_space_limit; end
    def key_space_limit=(_); end
    def multipart_part_limit; end
    def multipart_part_limit=(_); end
    def normalize_params(params, name, v = T.unsafe(nil), depth = T.unsafe(nil)); end
    def param_depth_limit; end
    def param_depth_limit=(_); end
    def params_hash_type?(obj); end
    def parse_nested_query(qs, d = T.unsafe(nil)); end
    def parse_query(qs, d = T.unsafe(nil), &unescaper); end
    def q_values(q_value_header); end
    def rfc2109(time); end
    def rfc2822(time); end
    def secure_compare(a, b); end
    def select_best_encoding(available_encodings, accept_encoding); end
    def set_cookie_header!(header, key, value); end
    def status_code(status); end
    def unescape(s, encoding = T.unsafe(nil)); end
  end
end

class Rack::Utils::Context
  def initialize(app_f, app_r); end

  def app; end
  def call(env); end
  def context(env, app = T.unsafe(nil)); end
  def for; end
  def recontext(app); end
end

Rack::Utils::DEFAULT_SEP = T.let(T.unsafe(nil), Regexp)

Rack::Utils::ESCAPE_HTML = T.let(T.unsafe(nil), Hash)

Rack::Utils::ESCAPE_HTML_PATTERN = T.let(T.unsafe(nil), Regexp)

Rack::Utils::HTTP_STATUS_CODES = T.let(T.unsafe(nil), Hash)

class Rack::Utils::HeaderHash < ::Hash
  def initialize(hash = T.unsafe(nil)); end

  def [](k); end
  def []=(k, v); end
  def delete(k); end
  def each; end
  def has_key?(k); end
  def include?(k); end
  def key?(k); end
  def member?(k); end
  def merge(other); end
  def merge!(other); end
  def replace(other); end
  def to_hash; end

  class << self
    def new(hash = T.unsafe(nil)); end
  end
end

class Rack::Utils::KeySpaceConstrainedParams
  def initialize(limit = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def key?(key); end
  def to_params_hash; end
end

Rack::Utils::Multipart = Rack::Multipart

module Rack::Utils::OkJson
  extend(::Rack::Utils::OkJson)

  def decode(s); end
  def encode(x); end
  def valenc(x); end

  private

  def abbrev(s); end
  def arrenc(a); end
  def arrparse(ts); end
  def eat(typ, ts); end
  def falsetok(s); end
  def hexdec4(s); end
  def keyenc(k); end
  def lex(s); end
  def nibble(c); end
  def nulltok(s); end
  def numenc(x); end
  def numtok(s); end
  def objenc(x); end
  def objparse(ts); end
  def pairparse(ts); end
  def rubydoesenc?; end
  def strenc(s); end
  def strtok(s); end
  def subst(u1, u2); end
  def surrogate?(u); end
  def textparse(ts); end
  def tok(s); end
  def truetok(s); end
  def ucharcopy(t, s, i); end
  def ucharenc(a, i, u); end
  def unquote(q); end
  def valparse(ts); end
end

class Rack::Utils::OkJson::Error < ::StandardError
end

Rack::Utils::OkJson::Spc = T.let(T.unsafe(nil), String)

Rack::Utils::OkJson::Uchar1max = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Uchar2max = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Uchar3max = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Ucharerr = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Umask2 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Umask3 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Umask4 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Umaskx = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Unesc = T.let(T.unsafe(nil), Hash)

Rack::Utils::OkJson::Upstream = T.let(T.unsafe(nil), String)

Rack::Utils::OkJson::Ustrerr = T.let(T.unsafe(nil), String)

Rack::Utils::OkJson::Usurr1 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Usurr2 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Usurr3 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Usurrself = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Utag2 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Utag3 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Utag4 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Utag5 = T.let(T.unsafe(nil), Fixnum)

Rack::Utils::OkJson::Utagx = T.let(T.unsafe(nil), Fixnum)

class Rack::Utils::OkJson::Utf8Error < ::StandardError
end

Rack::Utils::STATUS_WITH_NO_ENTITY_BODY = T.let(T.unsafe(nil), Set)

Rack::Utils::SYMBOL_TO_STATUS_CODE = T.let(T.unsafe(nil), Hash)

Rack::VERSION = T.let(T.unsafe(nil), Array)

class Rack::Multipart::MultipartLimitError < ::Errno::EMFILE
end

class Rack::RewindableInput
  def initialize(io); end

  def close; end
  def each(&block); end
  def gets; end
  def read(*args); end
  def rewind; end

  private

  def filesystem_has_posix_semantics?; end
  def make_rewindable; end
end

class Rack::RewindableInput::Tempfile < ::Tempfile
  def _close; end
end

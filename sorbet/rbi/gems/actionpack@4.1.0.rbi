# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actionpack` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module AbstractController
  extend(::ActiveSupport::Autoload)
end

class AbstractController::ActionNotFound < ::StandardError
end

module AbstractController::AssetPaths
  extend(::ActiveSupport::Concern)
end

class AbstractController::Base
  include(::ActiveSupport::Configurable)
  extend(::ActiveSupport::Configurable::ClassMethods)
  extend(::ActiveSupport::DescendantsTracker)

  def action_methods; end
  def action_name; end
  def action_name=(_); end
  def available_action?(action_name); end
  def controller_path; end
  def formats; end
  def formats=(_); end
  def process(action, *args); end
  def response_body; end
  def response_body=(_); end
  def send_action(*_); end

  private

  def _handle_action_missing(*args); end
  def action_method?(name); end
  def method_for_action(action_name); end
  def process_action(method_name, *args); end

  class << self
    def abstract; end
    def abstract!; end
    def abstract?; end
    def action_methods; end
    def clear_action_methods!; end
    def controller_path; end
    def hidden_actions; end
    def inherited(klass); end
    def internal_methods; end
    def method_added(name); end
  end
end

module AbstractController::Callbacks
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Callbacks)

  mixes_in_class_methods(::AbstractController::Callbacks::ClassMethods)

  def process_action(*args); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block = T.unsafe(nil)); end
  def _normalize_callback_option(options, from, to); end
  def _normalize_callback_options(options); end
  def after_action(*names, &blk); end
  def after_filter(*names, &blk); end
  def append_after_action(*names, &blk); end
  def append_after_filter(*names, &blk); end
  def append_around_action(*names, &blk); end
  def append_around_filter(*names, &blk); end
  def append_before_action(*names, &blk); end
  def append_before_filter(*names, &blk); end
  def around_action(*names, &blk); end
  def around_filter(*names, &blk); end
  def before_action(*names, &blk); end
  def before_filter(*names, &blk); end
  def prepend_after_action(*names, &blk); end
  def prepend_after_filter(*names, &blk); end
  def prepend_around_action(*names, &blk); end
  def prepend_around_filter(*names, &blk); end
  def prepend_before_action(*names, &blk); end
  def prepend_before_filter(*names, &blk); end
  def skip_action_callback(*names); end
  def skip_after_action(*names); end
  def skip_after_filter(*names); end
  def skip_around_action(*names); end
  def skip_around_filter(*names); end
  def skip_before_action(*names); end
  def skip_before_filter(*names); end
  def skip_filter(*names); end
end

module AbstractController::Collector
  def atom(*args, &block); end
  def bmp(*args, &block); end
  def css(*args, &block); end
  def csv(*args, &block); end
  def gif(*args, &block); end
  def html(*args, &block); end
  def ics(*args, &block); end
  def jpeg(*args, &block); end
  def js(*args, &block); end
  def json(*args, &block); end
  def mpeg(*args, &block); end
  def multipart_form(*args, &block); end
  def pdf(*args, &block); end
  def png(*args, &block); end
  def rss(*args, &block); end
  def text(*args, &block); end
  def tiff(*args, &block); end
  def url_encoded_form(*args, &block); end
  def vcf(*args, &block); end
  def xml(*args, &block); end
  def yaml(*args, &block); end
  def zip(*args, &block); end

  protected

  def method_missing(symbol, &block); end

  class << self
    def generate_method_for_mime(mime); end
  end
end

class AbstractController::DoubleRenderError < ::AbstractController::Error
  def initialize(message = T.unsafe(nil)); end
end

AbstractController::DoubleRenderError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

class AbstractController::Error < ::StandardError
end

module AbstractController::Helpers
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::AbstractController::Helpers::ClassMethods)
end

module AbstractController::Helpers::ClassMethods
  def clear_helpers; end
  def helper(*args, &block); end
  def helper_method(*meths); end
  def inherited(klass); end
  def modules_for_helpers(args); end

  private

  def add_template_helper(mod); end
  def default_helper_module!; end
end

AbstractController::Helpers::ClassMethods::MissingHelperError = T.let(T.unsafe(nil), ActiveSupport::Deprecation::DeprecatedConstantProxy)

class AbstractController::Helpers::MissingHelperError < ::LoadError
  def initialize(error, path); end
end

module AbstractController::Logger
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Benchmarkable)
end

module AbstractController::Railties
end

module AbstractController::Railties::RoutesHelpers
  class << self
    def with(routes); end
  end
end

module AbstractController::Rendering
  extend(::ActiveSupport::Concern)

  include(::ActionView::ViewPaths)

  def _normalize_args(action = T.unsafe(nil), options = T.unsafe(nil)); end
  def _normalize_options(options); end
  def _normalize_render(*args, &block); end
  def _process_format(format, options = T.unsafe(nil)); end
  def _process_options(options); end
  def _protected_ivars; end
  def render(*args, &block); end
  def render_to_body(options = T.unsafe(nil)); end
  def render_to_string(*args, &block); end
  def rendered_format; end
  def view_assigns; end
end

AbstractController::Rendering::DEFAULT_PROTECTED_INSTANCE_VARIABLES = T.let(T.unsafe(nil), Set)

module AbstractController::Translation
  def l(*args); end
  def localize(*args); end
  def t(*args); end
  def translate(*args); end
end

module AbstractController::UrlFor
  extend(::ActiveSupport::Concern)

  include(::ActionDispatch::Routing::UrlFor)

  mixes_in_class_methods(::AbstractController::UrlFor::ClassMethods)

  def _routes; end
end

module AbstractController::UrlFor::ClassMethods
  def _routes; end
  def action_methods; end
end

module ActionController
  extend(::ActiveSupport::Autoload)

  class << self
    def add_renderer(key, &block); end
    def eager_load!; end
  end
end

class ActionController::ActionControllerError < ::StandardError
end

class ActionController::BadRequest < ::ActionController::ActionControllerError
  def initialize(type = T.unsafe(nil), e = T.unsafe(nil)); end

  def original_exception; end
end

class ActionController::Base < ::ActionController::Metal
  include(::ActionView::ViewPaths)
  include(::AbstractController::Rendering)
  include(::AbstractController::Translation)
  include(::AbstractController::AssetPaths)
  include(::AbstractController::Helpers)
  include(::ActionController::Helpers)
  include(::ActionController::HideActions)
  include(::ActionController::ModelNaming)
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  include(::ActionDispatch::Routing::UrlFor)
  include(::AbstractController::UrlFor)
  include(::ActionController::UrlFor)
  include(::AbstractController::Logger)
  include(::ActiveSupport::Benchmarkable)
  include(::ActionController::RackDelegation)
  include(::ActionController::Redirecting)
  include(::ActionView::Rendering)
  include(::ActionView::Layouts)
  include(::ActionController::Rendering)
  include(::ActionController::Renderers)
  include(::ActionController::Renderers::All)
  include(::ActionController::Head)
  include(::ActionController::ConditionalGet)
  include(::ActiveSupport::Callbacks)
  include(::AbstractController::Callbacks)
  include(::ActionController::Caching::ConfigMethods)
  include(::ActionController::Caching::Fragments)
  include(::ActionController::Caching)
  include(::ActionController::MimeResponds)
  include(::ActionController::ImplicitRender)
  include(::ActiveSupport::Rescuable)
  include(::ActionController::StrongParameters)
  include(::ActionController::Cookies)
  include(::ActionController::Flash)
  include(::ActionController::RequestForgeryProtection)
  include(::ActionController::ForceSSL)
  include(::ActionController::Streaming)
  include(::ActionController::DataStreaming)
  include(::ActionController::HttpAuthentication::Basic::ControllerMethods)
  include(::ActionController::HttpAuthentication::Digest::ControllerMethods)
  include(::ActionController::HttpAuthentication::Token::ControllerMethods)
  include(::ActionController::Rescue)
  include(::ActionController::Instrumentation)
  include(::ActionController::ParamsWrapper)
  extend(::ActionView::ViewPaths::ClassMethods)
  extend(::AbstractController::Helpers::ClassMethods)
  extend(::ActionController::Helpers::ClassMethods)
  extend(::ActionController::HideActions::ClassMethods)
  extend(::AbstractController::UrlFor::ClassMethods)
  extend(::ActionView::Rendering::ClassMethods)
  extend(::ActionView::Layouts::ClassMethods)
  extend(::ActionController::Renderers::ClassMethods)
  extend(::ActionController::ConditionalGet::ClassMethods)
  extend(::ActiveSupport::Callbacks::ClassMethods)
  extend(::AbstractController::Callbacks::ClassMethods)
  extend(::ActionController::Caching::ClassMethods)
  extend(::ActionController::Caching::ConfigMethods)
  extend(::ActionController::MimeResponds::ClassMethods)
  extend(::ActiveSupport::Rescuable::ClassMethods)
  extend(::ActionController::Flash::ClassMethods)
  extend(::ActionController::RequestForgeryProtection::ClassMethods)
  extend(::ActionController::ForceSSL::ClassMethods)
  extend(::ActionController::HttpAuthentication::Basic::ControllerMethods::ClassMethods)
  extend(::ActionController::Instrumentation::ClassMethods)
  extend(::ActionController::ParamsWrapper::ClassMethods)

  def _helper_methods; end
  def _helper_methods=(_); end
  def _helper_methods?; end
  def _helpers; end
  def _helpers=(_); end
  def _helpers?; end
  def _process_action_callbacks; end
  def _process_action_callbacks=(_); end
  def _process_action_callbacks?; end
  def _protected_ivars; end
  def _renderers; end
  def _renderers=(_); end
  def _renderers?; end
  def _view_cache_dependencies; end
  def _view_cache_dependencies=(_); end
  def _view_cache_dependencies?; end
  def _view_paths; end
  def _view_paths=(_); end
  def _view_paths?; end
  def _wrapper_options; end
  def _wrapper_options=(_); end
  def _wrapper_options?; end
  def alert; end
  def allow_forgery_protection; end
  def allow_forgery_protection=(value); end
  def asset_host; end
  def asset_host=(value); end
  def assets_dir; end
  def assets_dir=(value); end
  def default_asset_host_protocol; end
  def default_asset_host_protocol=(value); end
  def default_static_extension; end
  def default_static_extension=(value); end
  def default_url_options; end
  def default_url_options=(_); end
  def default_url_options?; end
  def etaggers; end
  def etaggers=(_); end
  def etaggers?; end
  def flash(*args, &block); end
  def forgery_protection_strategy; end
  def forgery_protection_strategy=(value); end
  def helpers_path; end
  def helpers_path=(_); end
  def helpers_path?; end
  def hidden_actions; end
  def hidden_actions=(_); end
  def hidden_actions?; end
  def include_all_helpers; end
  def include_all_helpers=(_); end
  def include_all_helpers?; end
  def javascripts_dir; end
  def javascripts_dir=(value); end
  def logger; end
  def logger=(value); end
  def mimes_for_respond_to; end
  def mimes_for_respond_to=(_); end
  def mimes_for_respond_to?; end
  def notice; end
  def perform_caching; end
  def perform_caching=(value); end
  def relative_url_root; end
  def relative_url_root=(value); end
  def request_forgery_protection_token; end
  def request_forgery_protection_token=(value); end
  def rescue_handlers; end
  def rescue_handlers=(_); end
  def rescue_handlers?; end
  def responder; end
  def responder=(_); end
  def responder?; end
  def stylesheets_dir; end
  def stylesheets_dir=(value); end

  private

  def _layout; end

  class << self
    def _flash_types; end
    def _flash_types=(val); end
    def _flash_types?; end
    def _helper_methods; end
    def _helper_methods=(val); end
    def _helper_methods?; end
    def _helpers; end
    def _helpers=(val); end
    def _helpers?; end
    def _layout; end
    def _layout=(val); end
    def _layout?; end
    def _layout_conditions; end
    def _layout_conditions=(val); end
    def _layout_conditions?; end
    def _process_action_callbacks; end
    def _process_action_callbacks=(val); end
    def _process_action_callbacks?; end
    def _renderers; end
    def _renderers=(val); end
    def _renderers?; end
    def _view_cache_dependencies; end
    def _view_cache_dependencies=(val); end
    def _view_cache_dependencies?; end
    def _view_paths; end
    def _view_paths=(val); end
    def _view_paths?; end
    def _wrapper_options; end
    def _wrapper_options=(val); end
    def _wrapper_options?; end
    def allow_forgery_protection; end
    def allow_forgery_protection=(value); end
    def asset_host; end
    def asset_host=(value); end
    def assets_dir; end
    def assets_dir=(value); end
    def default_asset_host_protocol; end
    def default_asset_host_protocol=(value); end
    def default_static_extension; end
    def default_static_extension=(value); end
    def default_url_options; end
    def default_url_options=(val); end
    def default_url_options?; end
    def etaggers; end
    def etaggers=(val); end
    def etaggers?; end
    def forgery_protection_strategy; end
    def forgery_protection_strategy=(value); end
    def helpers_path; end
    def helpers_path=(val); end
    def helpers_path?; end
    def hidden_actions; end
    def hidden_actions=(val); end
    def hidden_actions?; end
    def include_all_helpers; end
    def include_all_helpers=(val); end
    def include_all_helpers?; end
    def javascripts_dir; end
    def javascripts_dir=(value); end
    def logger; end
    def logger=(value); end
    def middleware_stack; end
    def mimes_for_respond_to; end
    def mimes_for_respond_to=(val); end
    def mimes_for_respond_to?; end
    def perform_caching; end
    def perform_caching=(value); end
    def protected_instance_variables; end
    def relative_url_root; end
    def relative_url_root=(value); end
    def request_forgery_protection_token; end
    def request_forgery_protection_token=(value); end
    def rescue_handlers; end
    def rescue_handlers=(val); end
    def rescue_handlers?; end
    def responder; end
    def responder=(val); end
    def responder?; end
    def stylesheets_dir; end
    def stylesheets_dir=(value); end
    def without_modules(*modules); end
  end
end

ActionController::Base::MODULES = T.let(T.unsafe(nil), Array)

ActionController::Base::PROTECTED_IVARS = T.let(T.unsafe(nil), Set)

module ActionController::Caching
  include(::ActionController::Caching::ConfigMethods)
  include(::ActionController::Caching::Fragments)
  extend(::ActiveSupport::Concern)
  extend(::ActiveSupport::Autoload)

  include(::ActionController::RackDelegation)
  include(::ActiveSupport::Callbacks)
  include(::AbstractController::Callbacks)

  mixes_in_class_methods(::ActionController::Caching::ConfigMethods)

  def view_cache_dependencies; end

  protected

  def cache(key, options = T.unsafe(nil), &block); end
end

module ActionController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module ActionController::Caching::ConfigMethods
  def cache_store; end
  def cache_store=(store); end

  private

  def cache_configured?; end
end

module ActionController::Caching::Fragments
  def expire_fragment(key, options = T.unsafe(nil)); end
  def fragment_cache_key(key); end
  def fragment_exist?(key, options = T.unsafe(nil)); end
  def instrument_fragment_cache(name, key); end
  def read_fragment(key, options = T.unsafe(nil)); end
  def write_fragment(key, content, options = T.unsafe(nil)); end
end

module ActionController::ConditionalGet
  include(::ActionController::Head)
  extend(::ActiveSupport::Concern)

  include(::ActionController::RackDelegation)

  mixes_in_class_methods(::ActionController::ConditionalGet::ClassMethods)

  def expires_in(seconds, options = T.unsafe(nil)); end
  def expires_now; end
  def fresh_when(record_or_options, additional_options = T.unsafe(nil)); end
  def stale?(record_or_options, additional_options = T.unsafe(nil)); end

  private

  def combine_etags(etag); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::Cookies
  extend(::ActiveSupport::Concern)

  include(::ActionController::RackDelegation)


  private

  def cookies; end
end

module ActionController::DataStreaming
  extend(::ActiveSupport::Concern)

  include(::ActionController::Rendering)


  protected

  def send_data(data, options = T.unsafe(nil)); end
  def send_file(path, options = T.unsafe(nil)); end

  private

  def send_file_headers!(options); end
end

ActionController::DataStreaming::DEFAULT_SEND_FILE_DISPOSITION = T.let(T.unsafe(nil), String)

ActionController::DataStreaming::DEFAULT_SEND_FILE_TYPE = T.let(T.unsafe(nil), String)

class ActionController::DataStreaming::FileBody
  def initialize(path); end

  def each; end
  def to_path; end
end

module ActionController::Flash
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionController::Flash::ClassMethods)


  protected

  def redirect_to(options = T.unsafe(nil), response_status_and_flash = T.unsafe(nil)); end
end

module ActionController::Flash::ClassMethods
  def add_flash_types(*types); end
end

module ActionController::ForceSSL
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Callbacks)
  include(::AbstractController::Callbacks)

  mixes_in_class_methods(::ActionController::ForceSSL::ClassMethods)

  def force_ssl_redirect(host_or_options = T.unsafe(nil)); end
end

ActionController::ForceSSL::ACTION_OPTIONS = T.let(T.unsafe(nil), Array)

module ActionController::ForceSSL::ClassMethods
  def force_ssl(options = T.unsafe(nil)); end
end

ActionController::ForceSSL::REDIRECT_OPTIONS = T.let(T.unsafe(nil), Array)

ActionController::ForceSSL::URL_OPTIONS = T.let(T.unsafe(nil), Array)

module ActionController::Head
  def head(status, options = T.unsafe(nil)); end

  private

  def include_content?(status); end
end

module ActionController::Helpers
  extend(::ActiveSupport::Concern)

  include(::AbstractController::Helpers)

  mixes_in_class_methods(::ActionController::Helpers::ClassMethods)

  class << self
    def helpers_path; end
    def helpers_path=(_); end
  end
end

module ActionController::Helpers::ClassMethods
  def all_helpers_from_path(path); end
  def helper_attr(*attrs); end
  def helpers; end
  def modules_for_helpers(args); end

  private

  def all_application_helpers; end
end

module ActionController::HideActions
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionController::HideActions::ClassMethods)


  private

  def method_for_action(action_name); end
end

module ActionController::HideActions::ClassMethods
  def action_methods; end
  def hide_action(*args); end
  def visible_action?(action_name); end
end

module ActionController::HttpAuthentication
end

module ActionController::HttpAuthentication::Basic
  extend(::ActionController::HttpAuthentication::Basic)

  def authenticate(request, &login_procedure); end
  def authentication_request(controller, realm); end
  def decode_credentials(request); end
  def encode_credentials(user_name, password); end
  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionController::HttpAuthentication::Basic::ControllerMethods::ClassMethods)

  def authenticate_or_request_with_http_basic(realm = T.unsafe(nil), &login_procedure); end
  def authenticate_with_http_basic(&login_procedure); end
  def request_http_basic_authentication(realm = T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods::ClassMethods
  def http_basic_authenticate_with(options = T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest
  extend(::ActionController::HttpAuthentication::Digest)

  def authenticate(request, realm, &password_procedure); end
  def authentication_header(controller, realm); end
  def authentication_request(controller, realm, message = T.unsafe(nil)); end
  def decode_credentials(header); end
  def decode_credentials_header(request); end
  def encode_credentials(http_method, credentials, password, password_is_ha1); end
  def expected_response(http_method, uri, credentials, password, password_is_ha1 = T.unsafe(nil)); end
  def ha1(credentials, password); end
  def nonce(secret_key, time = T.unsafe(nil)); end
  def opaque(secret_key); end
  def secret_token(request); end
  def validate_digest_response(request, realm, &password_procedure); end
  def validate_nonce(secret_key, request, value, seconds_to_timeout = T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm = T.unsafe(nil), &password_procedure); end
  def authenticate_with_http_digest(realm = T.unsafe(nil), &password_procedure); end
  def request_http_digest_authentication(realm = T.unsafe(nil), message = T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token
  extend(::ActionController::HttpAuthentication::Token)

  def authenticate(controller, &login_procedure); end
  def authentication_request(controller, realm); end
  def encode_credentials(token, options = T.unsafe(nil)); end
  def params_array_from(raw_params); end
  def raw_params(auth); end
  def rewrite_param_values(array_params); end
  def token_and_options(request); end
  def token_params_from(auth); end
end

ActionController::HttpAuthentication::Token::AUTHN_PAIR_DELIMITERS = T.let(T.unsafe(nil), Regexp)

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm = T.unsafe(nil), &login_procedure); end
  def authenticate_with_http_token(&login_procedure); end
  def request_http_token_authentication(realm = T.unsafe(nil)); end
end

ActionController::HttpAuthentication::Token::TOKEN_REGEX = T.let(T.unsafe(nil), Regexp)

module ActionController::ImplicitRender
  def default_render(*args); end
  def method_for_action(action_name); end
  def send_action(method, *args); end
end

module ActionController::Instrumentation
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Benchmarkable)
  include(::AbstractController::Logger)
  include(::ActionController::RackDelegation)

  mixes_in_class_methods(::ActionController::Instrumentation::ClassMethods)

  def process_action(*args); end
  def redirect_to(*args); end
  def render(*args); end
  def send_data(data, options = T.unsafe(nil)); end
  def send_file(path, options = T.unsafe(nil)); end
  def view_runtime; end
  def view_runtime=(_); end

  private

  def append_info_to_payload(payload); end
  def cleanup_view_runtime; end
  def halted_callback_hook(filter); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

class ActionController::InvalidAuthenticityToken < ::ActionController::ActionControllerError
end

class ActionController::InvalidCrossOriginRequest < ::ActionController::ActionControllerError
end

module ActionController::Live
  def log_error(exception); end
  def process(name); end
  def response_body=(body); end
  def set_response!(request); end
end

class ActionController::Live::Buffer < ::ActionDispatch::Response::Buffer
  include(::MonitorMixin)

  def initialize(response); end

  def await_close; end
  def call_on_error; end
  def close; end
  def each; end
  def on_error(&block); end
  def write(string); end
end

class ActionController::Live::Response < ::ActionDispatch::Response

  private

  def before_committed; end
  def before_sending; end
  def build_buffer(response, body); end
  def handle_conditional_get!; end
  def merge_default_headers(original, default); end
end

class ActionController::Live::Response::Header
  def initialize(response, header); end

  def []=(k, v); end
  def merge(other); end
  def to_hash; end
end

class ActionController::Live::SSE
  def initialize(stream, options = T.unsafe(nil)); end

  def close; end
  def write(object, options = T.unsafe(nil)); end

  private

  def perform_write(json, options); end
end

ActionController::Live::SSE::WHITELISTED_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionController::LogSubscriber < ::ActiveSupport::LogSubscriber
  def deep_munge(event); end
  def exist_fragment?(event); end
  def expire_fragment(event); end
  def expire_page(event); end
  def halted_callback(event); end
  def logger; end
  def process_action(event); end
  def read_fragment(event); end
  def redirect_to(event); end
  def send_data(event); end
  def send_file(event); end
  def start_processing(event); end
  def unpermitted_parameters(event); end
  def write_fragment(event); end
  def write_page(event); end
end

ActionController::LogSubscriber::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)

class ActionController::Metal < ::AbstractController::Base
  def initialize; end

  def content_type; end
  def content_type=(type); end
  def controller_name; end
  def dispatch(name, request); end
  def env; end
  def env=(_); end
  def headers; end
  def headers=(_); end
  def location; end
  def location=(url); end
  def middleware_stack; end
  def middleware_stack=(_); end
  def middleware_stack?; end
  def params; end
  def params=(val); end
  def performed?; end
  def request; end
  def request=(_); end
  def response; end
  def response=(_); end
  def response_body=(body); end
  def session(*args, &block); end
  def status; end
  def status=(status); end
  def to_a; end
  def url_for(string); end

  class << self
    def action(name, klass = T.unsafe(nil)); end
    def call(env); end
    def controller_name; end
    def inherited(base); end
    def middleware; end
    def middleware_stack; end
    def middleware_stack=(val); end
    def middleware_stack?; end
    def use(*args, &block); end
  end
end

class ActionController::MethodNotAllowed < ::ActionController::ActionControllerError
  def initialize(*allowed_methods); end
end

class ActionController::Middleware < ::ActionController::Metal
  def initialize(app); end

  def app; end
  def app=(_); end
  def index; end
  def process(action); end

  class << self
    def build(*_); end
    def middleware_stack; end
    def new(app); end
  end
end

class ActionController::Middleware::ActionMiddleware
  def initialize(controller, app); end

  def call(env); end
end

class ActionController::MiddlewareStack < ::ActionDispatch::MiddlewareStack
  def build(action, app = T.unsafe(nil), &block); end
end

class ActionController::MiddlewareStack::Middleware < ::ActionDispatch::MiddlewareStack::Middleware
  def initialize(klass, *args, &block); end

  def valid?(action); end
end

module ActionController::MimeResponds
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionController::MimeResponds::ClassMethods)

  def respond_to(*mimes, &block); end
  def respond_with(*resources, &block); end

  protected

  def collect_mimes_from_class_level; end
  def retrieve_collector_from_mimes(mimes = T.unsafe(nil), &block); end
end

module ActionController::MimeResponds::ClassMethods
  def clear_respond_to; end
  def respond_to(*mimes); end
end

class ActionController::MimeResponds::Collector
  include(::AbstractController::Collector)

  def initialize(mimes, variant = T.unsafe(nil)); end

  def all(*args, &block); end
  def any(*args, &block); end
  def custom(mime_type, &block); end
  def format; end
  def format=(_); end
  def negotiate_format(request); end
  def response; end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def initialize(variant = T.unsafe(nil)); end

  def all(*args, &block); end
  def any(*args, &block); end
  def method_missing(name, *args, &block); end
  def variant; end
end

class ActionController::MissingFile < ::ActionController::ActionControllerError
end

class ActionController::MissingRenderer < ::LoadError
  def initialize(format); end
end

module ActionController::ModelNaming
  def convert_to_model(object); end
  def model_name_from_record_or_class(record_or_class); end
end

class ActionController::NotImplemented < ::ActionController::MethodNotAllowed
end

class ActionController::ParameterMissing < ::KeyError
  def initialize(param); end

  def param; end
end

class ActionController::Parameters < ::ActiveSupport::HashWithIndifferentAccess
  def initialize(attributes = T.unsafe(nil)); end

  def [](key); end
  def converted_arrays; end
  def dup; end
  def fetch(key, *args); end
  def permit(*filters); end
  def permit!; end
  def permitted?; end
  def require(key); end
  def required(key); end
  def slice(*keys); end

  protected

  def permitted=(new_permitted); end

  private

  def array_of_permitted_scalars?(value); end
  def array_of_permitted_scalars_filter(params, key); end
  def convert_hashes_to_parameters(key, value, assign_if_converted = T.unsafe(nil)); end
  def convert_value_to_parameters(value); end
  def each_element(object); end
  def fields_for_style?(object); end
  def hash_filter(params, filter); end
  def permitted_scalar?(value); end
  def permitted_scalar_filter(params, key); end
  def unpermitted_keys(params); end
  def unpermitted_parameters!(params); end

  class << self
    def action_on_unpermitted_parameters; end
    def action_on_unpermitted_parameters=(obj); end
    def permit_all_parameters; end
    def permit_all_parameters=(obj); end
  end
end

ActionController::Parameters::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

ActionController::Parameters::NEVER_UNPERMITTED_PARAMS = T.let(T.unsafe(nil), Array)

ActionController::Parameters::PERMITTED_SCALAR_TYPES = T.let(T.unsafe(nil), Array)

module ActionController::ParamsWrapper
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionController::ParamsWrapper::ClassMethods)

  def process_action(*args); end

  private

  def _extract_parameters(parameters); end
  def _wrap_parameters(parameters); end
  def _wrapper_enabled?; end
  def _wrapper_formats; end
  def _wrapper_key; end
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end
  def inherited(klass); end
  def wrap_parameters(name_or_model_or_options, options = T.unsafe(nil)); end
end

ActionController::ParamsWrapper::EXCLUDE_PARAMETERS = T.let(T.unsafe(nil), Array)

class ActionController::ParamsWrapper::Options < ::Struct
  include(::Mutex_m)

  def initialize(name, format, include, exclude, klass, model); end

  def include; end
  def lock; end
  def locked?; end
  def model; end
  def name; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end

  private

  def _default_wrap_model; end

  class << self
    def from_hash(hash); end
  end
end

module ActionController::RackDelegation
  extend(::ActiveSupport::Concern)

  def content_type(*args, &block); end
  def content_type=(arg); end
  def dispatch(action, request); end
  def headers(*args, &block); end
  def location(*args, &block); end
  def location=(arg); end
  def reset_session; end
  def response_body=(body); end
  def status(*args, &block); end
  def status=(arg); end

  private

  def set_response!(request); end
end

class ActionController::Railtie < ::Rails::Railtie
end

module ActionController::Railties
end

module ActionController::Railties::Helpers
  def inherited(klass); end
end

class ActionController::RedirectBackError < ::AbstractController::Error
  def initialize(message = T.unsafe(nil)); end
end

ActionController::RedirectBackError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

module ActionController::Redirecting
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Benchmarkable)
  include(::AbstractController::Logger)
  include(::ActionController::RackDelegation)
  include(::ActionDispatch::Routing::UrlFor)
  include(::AbstractController::UrlFor)
  include(::ActionController::UrlFor)

  def _compute_redirect_to_location(options); end
  def redirect_to(options = T.unsafe(nil), response_status = T.unsafe(nil)); end

  private

  def _extract_redirect_to_status(options, response_status); end
end

class ActionController::RenderError < ::ActionController::ActionControllerError
end

module ActionController::Renderers
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActionController::Renderers::ClassMethods)

  def _handle_render_options(options); end
  def _render_option_js(js, options); end
  def _render_option_json(json, options); end
  def _render_option_xml(xml, options); end
  def render_to_body(options); end

  class << self
    def add(key, &block); end
  end
end

module ActionController::Renderers::All
  extend(::ActiveSupport::Concern)

  include(::ActionController::Renderers)
end

module ActionController::Renderers::ClassMethods
  def use_renderer(*args); end
  def use_renderers(*args); end
end

ActionController::Renderers::RENDERERS = T.let(T.unsafe(nil), Set)

module ActionController::Rendering
  extend(::ActiveSupport::Concern)

  def process_action(*_); end
  def render(*args); end
  def render_to_body(options = T.unsafe(nil)); end
  def render_to_string(*_); end

  private

  def _any_render_format_is_nil?(options); end
  def _normalize_args(action = T.unsafe(nil), options = T.unsafe(nil), &blk); end
  def _normalize_options(options); end
  def _normalize_text(options); end
  def _process_format(format, options = T.unsafe(nil)); end
  def _process_options(options); end
  def _render_in_priorities(options); end
end

ActionController::Rendering::RENDER_FORMATS_IN_PRIORITY = T.let(T.unsafe(nil), Array)

module ActionController::RequestForgeryProtection
  extend(::ActiveSupport::Concern)

  include(::AbstractController::Helpers)
  include(::ActiveSupport::Callbacks)
  include(::AbstractController::Callbacks)

  mixes_in_class_methods(::ActionController::RequestForgeryProtection::ClassMethods)


  protected

  def form_authenticity_param; end
  def form_authenticity_token; end
  def handle_unverified_request; end
  def mark_for_same_origin_verification!; end
  def marked_for_same_origin_verification?; end
  def non_xhr_javascript_response?; end
  def protect_against_forgery?; end
  def verified_request?; end
  def verify_authenticity_token; end
  def verify_same_origin_request; end
end

module ActionController::RequestForgeryProtection::ClassMethods
  def protect_from_forgery(options = T.unsafe(nil)); end

  private

  def protection_method_class(name); end
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def initialize(controller); end

  def handle_unverified_request; end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def initialize(controller); end

  def handle_unverified_request; end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar < ::ActionDispatch::Cookies::CookieJar
  def write(*_); end

  class << self
    def build(request); end
  end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash < ::Rack::Session::Abstract::SessionHash
  def initialize(env); end

  def destroy; end
  def exists?; end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def initialize(controller); end

  def handle_unverified_request; end
end

module ActionController::Rescue
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Rescuable)

  def rescue_with_handler(exception); end
  def show_detailed_exceptions?; end

  private

  def process_action(*args); end
end

class ActionController::Responder
  def initialize(controller, resources, options = T.unsafe(nil)); end

  def controller; end
  def delete?(*args, &block); end
  def format; end
  def get?(*args, &block); end
  def head(*args, &block); end
  def options; end
  def patch?(*args, &block); end
  def post?(*args, &block); end
  def put?(*args, &block); end
  def redirect_to(*args, &block); end
  def render(*args, &block); end
  def request; end
  def resource; end
  def resources; end
  def respond; end
  def to_format; end
  def to_html; end
  def to_js; end

  protected

  def api_behavior(error); end
  def api_location; end
  def default_action; end
  def default_render; end
  def display(resource, given_options = T.unsafe(nil)); end
  def display_errors; end
  def has_errors?; end
  def has_renderer?; end
  def json_resource_errors; end
  def navigation_behavior(error); end
  def navigation_location; end
  def resource_errors; end
  def resource_location; end
  def resourceful?; end
  def response_overridden?; end

  class << self
    def call(*args); end
  end
end

ActionController::Responder::DEFAULT_ACTIONS_FOR_VERBS = T.let(T.unsafe(nil), Hash)

class ActionController::RoutingError < ::ActionController::ActionControllerError
  def initialize(message, failures = T.unsafe(nil)); end

  def failures; end
end

class ActionController::SessionOverflowError < ::ActionController::ActionControllerError
  def initialize(message = T.unsafe(nil)); end
end

ActionController::SessionOverflowError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

module ActionController::Streaming
  extend(::ActiveSupport::Concern)


  protected

  def _process_options(options); end
  def _render_template(options); end
end

module ActionController::StrongParameters
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Rescuable)

  def params; end
  def params=(value); end
end

module ActionController::TemplateAssertions
  extend(::ActiveSupport::Concern)

  def assert_template(options = T.unsafe(nil), message = T.unsafe(nil)); end
  def process(*args); end
  def setup_subscriptions; end
  def teardown_subscriptions; end
end

class ActionController::TestCase < ::ActiveSupport::TestCase
  include(::ActiveSupport::Testing::ConstantLookup)
  include(::ActionDispatch::TestProcess)
  include(::ActionController::TestCase::Behavior)
  include(::ActionController::TemplateAssertions)
  include(::ActionDispatch::Assertions::DomAssertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions::SelectorAssertions)
  include(::ActionDispatch::Assertions::TagAssertions)
  include(::ActionDispatch::Assertions)
  extend(::ActiveSupport::Testing::ConstantLookup::ClassMethods)
  extend(::ActionController::TestCase::Behavior::ClassMethods)

  def _controller_class; end
  def _controller_class=(_); end
  def _controller_class?; end

  class << self
    def _controller_class; end
    def _controller_class=(val); end
    def _controller_class?; end
    def _setup_callbacks; end
    def _teardown_callbacks; end
  end
end

module ActionController::TestCase::Behavior
  include(::ActionDispatch::TestProcess)
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Testing::ConstantLookup)
  include(::ActionController::TemplateAssertions)
  include(::ActionDispatch::Assertions)

  mixes_in_class_methods(::ActionController::TestCase::Behavior::ClassMethods)

  def build_request; end
  def build_response(klass); end
  def delete(action, *args); end
  def get(action, *args); end
  def head(action, *args); end
  def paramify_values(hash_or_array_or_value); end
  def patch(action, *args); end
  def post(action, *args); end
  def process(action, http_method = T.unsafe(nil), *args); end
  def put(action, *args); end
  def request; end
  def response; end
  def setup_controller_request_and_response; end
  def xhr(request_method, action, parameters = T.unsafe(nil), session = T.unsafe(nil), flash = T.unsafe(nil)); end
  def xml_http_request(request_method, action, parameters = T.unsafe(nil), session = T.unsafe(nil), flash = T.unsafe(nil)); end

  private

  def build_request_uri(action, parameters); end
  def check_required_ivars; end
  def html_format?(parameters); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class; end
  def controller_class=(new_class); end
  def determine_default_controller_class(name); end
  def prepare_controller_class(new_class); end
  def tests(controller_class); end
end

module ActionController::TestCase::RaiseActionExceptions

  protected

  def rescue_action_without_handler(e); end

  class << self
    def included(base); end
  end
end

module ActionController::Testing
  extend(::ActiveSupport::Concern)

  include(::ActionController::RackDelegation)

  mixes_in_class_methods(::ActionController::Testing::ClassMethods)

  def headers=(new_headers); end
end

module ActionController::Testing::ClassMethods
  def before_filters; end
end

module ActionController::Testing::Functional
  def recycle!; end
  def set_response!(request); end
end

class ActionController::UnknownController < ::ActionController::ActionControllerError
end

class ActionController::UnknownFormat < ::ActionController::ActionControllerError
end

class ActionController::UnknownHttpMethod < ::ActionController::ActionControllerError
end

class ActionController::UnpermittedParameters < ::IndexError
  def initialize(params); end

  def params; end
end

module ActionController::UrlFor
  extend(::ActiveSupport::Concern)

  include(::ActionDispatch::Routing::UrlFor)
  include(::AbstractController::UrlFor)

  def url_options; end
end

class ActionController::UrlGenerationError < ::ActionController::RoutingError
end

class ActionController::LiveTestResponse < ::ActionController::Live::Response
  def body; end
  def error?; end
  def missing?; end
  def recycle!; end
  def redirect?; end
  def success?; end
end

class ActionController::TestRequest < ::ActionDispatch::TestRequest
  def initialize(env = T.unsafe(nil)); end

  def assign_parameters(routes, controller_path, action, parameters = T.unsafe(nil)); end
  def recycle!; end

  private

  def default_env; end
end

ActionController::TestRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class ActionController::TestResponse < ::ActionDispatch::TestResponse
  def recycle!; end
end

class ActionController::TestSession < ::Rack::Session::Abstract::SessionHash
  def initialize(session = T.unsafe(nil)); end

  def destroy; end
  def exists?; end
  def keys; end
  def values; end

  private

  def load!; end
end

ActionController::TestSession::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

module ActionDispatch
  extend(::ActiveSupport::Autoload)

  def test_app; end
  def test_app=(obj); end

  class << self
    def test_app; end
    def test_app=(obj); end
  end
end

module ActionDispatch::Assertions
  include(::ActionDispatch::Assertions::DomAssertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions::SelectorAssertions)
  include(::ActionDispatch::Assertions::TagAssertions)
  extend(::ActiveSupport::Concern)
end

module ActionDispatch::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message = T.unsafe(nil)); end
  def assert_dom_not_equal(expected, actual, message = T.unsafe(nil)); end
end

ActionDispatch::Assertions::NO_STRIP = T.let(T.unsafe(nil), Array)

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_response(type, message = T.unsafe(nil)); end

  private

  def normalize_argument_to_redirection(fragment); end
  def parameterize(value); end
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults = T.unsafe(nil), extras = T.unsafe(nil), message = T.unsafe(nil)); end
  def assert_recognizes(expected_options, path, extras = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_routing(path, options, defaults = T.unsafe(nil), extras = T.unsafe(nil), message = T.unsafe(nil)); end
  def method_missing(selector, *args, &block); end
  def with_routing; end

  private

  def fail_on(exception_class); end
  def recognized_request_for(path, extras = T.unsafe(nil)); end
end

module ActionDispatch::Assertions::SelectorAssertions
  def assert_select(*args, &block); end
  def assert_select_email(&block); end
  def assert_select_encoded(element = T.unsafe(nil), &block); end
  def count_description(min, max, count); end
  def css_select(*args); end

  protected

  def response_from_page; end
end

module ActionDispatch::Assertions::TagAssertions
  def assert_no_tag(*opts); end
  def assert_tag(*opts); end
  def find_all_tag(conditions); end
  def find_tag(conditions); end
  def html_document; end
end

class ActionDispatch::Callbacks
  include(::ActiveSupport::Callbacks)
  extend(::ActiveSupport::Callbacks::ClassMethods)
  extend(::ActiveSupport::DescendantsTracker)

  def initialize(app); end

  def _call_callbacks; end
  def _call_callbacks=(_); end
  def _call_callbacks?; end
  def call(env); end

  class << self
    def _call_callbacks; end
    def _call_callbacks=(val); end
    def _call_callbacks?; end
    def after(*args, &block); end
    def before(*args, &block); end
    def to_cleanup(*args, &block); end
    def to_prepare(*args, &block); end
  end
end

class ActionDispatch::Cookies
  def initialize(app); end

  def call(env); end
end

ActionDispatch::Cookies::COOKIES_SERIALIZER = T.let(T.unsafe(nil), String)

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted; end
  def permanent; end
  def signed; end
  def signed_or_encrypted; end
end

class ActionDispatch::Cookies::CookieJar
  include(::ActionDispatch::Cookies::ChainedCookieJars)
  include(::Enumerable)

  def initialize(key_generator, host = T.unsafe(nil), secure = T.unsafe(nil), options = T.unsafe(nil)); end

  def [](name); end
  def []=(name, options); end
  def always_write_cookie; end
  def always_write_cookie=(obj); end
  def clear(options = T.unsafe(nil)); end
  def commit!; end
  def committed?; end
  def delete(name, options = T.unsafe(nil)); end
  def deleted?(name, options = T.unsafe(nil)); end
  def each(&block); end
  def fetch(name, *args, &block); end
  def handle_options(options); end
  def has_key?(name); end
  def key?(name); end
  def recycle!; end
  def update(other_hash); end
  def write(headers); end

  private

  def write_cookie?(cookie); end

  class << self
    def always_write_cookie; end
    def always_write_cookie=(obj); end
    def build(request); end
    def options_for_env(env); end
  end
end

ActionDispatch::Cookies::CookieJar::DOMAIN_REGEXP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Cookies::CookieOverflow < ::StandardError
end

ActionDispatch::Cookies::ENCRYPTED_COOKIE_SALT = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::ENCRYPTED_SIGNED_COOKIE_SALT = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::EncryptedCookieJar
  include(::ActionDispatch::Cookies::ChainedCookieJars)
  include(::ActionDispatch::Cookies::SerializedCookieJars)

  def initialize(parent_jar, key_generator, options = T.unsafe(nil)); end

  def [](name); end
  def []=(name, options); end

  private

  def decrypt_and_verify(encrypted_message); end
end

ActionDispatch::Cookies::GENERATOR_KEY = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::HTTP_HEADER = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::JsonSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

ActionDispatch::Cookies::MAX_COOKIE_SIZE = T.let(T.unsafe(nil), Fixnum)

class ActionDispatch::Cookies::NullSerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

class ActionDispatch::Cookies::PermanentCookieJar
  include(::ActionDispatch::Cookies::ChainedCookieJars)

  def initialize(parent_jar, key_generator, options = T.unsafe(nil)); end

  def [](name); end
  def []=(name, options); end
end

ActionDispatch::Cookies::SECRET_KEY_BASE = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::SECRET_TOKEN = T.let(T.unsafe(nil), String)

ActionDispatch::Cookies::SIGNED_COOKIE_SALT = T.let(T.unsafe(nil), String)

module ActionDispatch::Cookies::SerializedCookieJars

  protected

  def deserialize(name, value); end
  def needs_migration?(value); end
  def serialize(name, value); end
  def serializer; end
end

ActionDispatch::Cookies::SerializedCookieJars::MARSHAL_SIGNATURE = T.let(T.unsafe(nil), String)

class ActionDispatch::Cookies::SignedCookieJar
  include(::ActionDispatch::Cookies::ChainedCookieJars)
  include(::ActionDispatch::Cookies::SerializedCookieJars)

  def initialize(parent_jar, key_generator, options = T.unsafe(nil)); end

  def [](name); end
  def []=(name, options); end

  private

  def verify(signed_message); end
end

class ActionDispatch::Cookies::UpgradeLegacyEncryptedCookieJar < ::ActionDispatch::Cookies::EncryptedCookieJar
  include(::ActionDispatch::Cookies::VerifyAndUpgradeLegacySignedMessage)

  def [](name); end
end

class ActionDispatch::Cookies::UpgradeLegacySignedCookieJar < ::ActionDispatch::Cookies::SignedCookieJar
  include(::ActionDispatch::Cookies::VerifyAndUpgradeLegacySignedMessage)

  def [](name); end
end

module ActionDispatch::Cookies::VerifyAndUpgradeLegacySignedMessage
  def initialize(*args); end

  def verify_and_upgrade_legacy_signed_message(name, signed_message); end
end

class ActionDispatch::DebugExceptions
  def initialize(app, routes_app = T.unsafe(nil)); end

  def call(env); end

  private

  def log_error(env, wrapper); end
  def logger(env); end
  def render(status, body, format); end
  def render_exception(env, exception); end
  def routes_inspector(exception); end
  def stderr_logger; end
end

ActionDispatch::DebugExceptions::RESCUES_TEMPLATE_PATH = T.let(T.unsafe(nil), String)

class ActionDispatch::ExceptionWrapper
  def initialize(env, exception); end

  def application_trace; end
  def env; end
  def exception; end
  def file; end
  def framework_trace; end
  def full_trace; end
  def line_number; end
  def rescue_responses; end
  def rescue_responses=(obj); end
  def rescue_template; end
  def rescue_templates; end
  def rescue_templates=(obj); end
  def source_extract; end
  def status_code; end

  private

  def backtrace_cleaner; end
  def clean_backtrace(*args); end
  def original_exception(exception); end
  def registered_original_exception?(exception); end
  def source_fragment(path, line); end

  class << self
    def rescue_responses; end
    def rescue_responses=(obj); end
    def rescue_templates; end
    def rescue_templates=(obj); end
    def status_code_for_exception(class_name); end
  end
end

class ActionDispatch::Flash
  def initialize(app); end

  def call(env); end
end

class ActionDispatch::Flash::FlashHash
  include(::Enumerable)

  def initialize(flashes = T.unsafe(nil), discard = T.unsafe(nil)); end

  def [](k); end
  def []=(k, v); end
  def alert; end
  def alert=(message); end
  def clear; end
  def delete(key); end
  def discard(k = T.unsafe(nil)); end
  def each(&block); end
  def empty?; end
  def keep(k = T.unsafe(nil)); end
  def key?(name); end
  def keys; end
  def merge!(h); end
  def notice; end
  def notice=(message); end
  def now; end
  def replace(h); end
  def sweep; end
  def to_hash; end
  def to_session_value; end
  def update(h); end

  protected

  def now_is_loaded?; end
  def stringify_array(array); end

  private

  def initialize_copy(other); end

  class << self
    def from_session_value(value); end
  end
end

class ActionDispatch::Flash::FlashNow
  def initialize(flash); end

  def [](k); end
  def []=(k, v); end
  def alert=(message); end
  def flash; end
  def flash=(_); end
  def notice=(message); end
end

ActionDispatch::Flash::KEY = T.let(T.unsafe(nil), String)

module ActionDispatch::Http
  extend(::ActiveSupport::Autoload)
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end
  def fresh?(response); end
  def if_modified_since; end
  def if_none_match; end
  def if_none_match_etags; end
  def not_modified?(modified_at); end
end

ActionDispatch::Http::Cache::Request::HTTP_IF_MODIFIED_SINCE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Request::HTTP_IF_NONE_MATCH = T.let(T.unsafe(nil), String)

module ActionDispatch::Http::Cache::Response
  def cache_control; end
  def date; end
  def date=(utc_time); end
  def date?; end
  def etag; end
  def etag=(etag); end
  def etag?; end
  def last_modified; end
  def last_modified=(utc_time); end
  def last_modified?; end

  private

  def cache_control_headers; end
  def cache_control_segments; end
  def handle_conditional_get!; end
  def prepare_cache_control!; end
  def set_conditional_cache_control!; end
end

ActionDispatch::Http::Cache::Response::CACHE_CONTROL = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::DEFAULT_CACHE_CONTROL = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::ETAG = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::LAST_MODIFIED = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::MUST_REVALIDATE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::NO_CACHE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::PRIVATE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::PUBLIC = T.let(T.unsafe(nil), String)

ActionDispatch::Http::Cache::Response::SPECIAL_KEYS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Http::FilterParameters
  def initialize(env); end

  def filtered_env; end
  def filtered_parameters; end
  def filtered_path; end

  protected

  def env_filter; end
  def filtered_query_string; end
  def parameter_filter; end
  def parameter_filter_for(filters); end
end

ActionDispatch::Http::FilterParameters::ENV_MATCH = T.let(T.unsafe(nil), Array)

ActionDispatch::Http::FilterParameters::KV_RE = T.let(T.unsafe(nil), String)

ActionDispatch::Http::FilterParameters::NULL_ENV_FILTER = T.let(T.unsafe(nil), ActionDispatch::Http::ParameterFilter)

ActionDispatch::Http::FilterParameters::NULL_PARAM_FILTER = T.let(T.unsafe(nil), ActionDispatch::Http::ParameterFilter)

ActionDispatch::Http::FilterParameters::PAIR_RE = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Http::FilterRedirect
  def filtered_location; end

  private

  def location_filter; end
  def location_filter_match?(filters); end
end

ActionDispatch::Http::FilterRedirect::FILTERED = T.let(T.unsafe(nil), String)

class ActionDispatch::Http::Headers
  include(::Enumerable)

  def initialize(env = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def each(&block); end
  def env; end
  def fetch(key, *args, &block); end
  def include?(key); end
  def key?(key); end
  def merge(headers_or_env); end
  def merge!(headers_or_env); end

  private

  def env_name(key); end
end

ActionDispatch::Http::Headers::CGI_VARIABLES = T.let(T.unsafe(nil), Array)

ActionDispatch::Http::Headers::HTTP_HEADER = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Http::MimeNegotiation
  extend(::ActiveSupport::Concern)

  def accepts; end
  def content_mime_type; end
  def content_type; end
  def format(view_path = T.unsafe(nil)); end
  def format=(extension); end
  def formats; end
  def formats=(extensions); end
  def negotiate_mime(order); end
  def variant; end
  def variant=(variant); end

  protected

  def use_accept_header; end
  def valid_accept_header; end
end

ActionDispatch::Http::MimeNegotiation::BROWSER_LIKE_ACCEPTS = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Http::ParameterFilter
  def initialize(filters = T.unsafe(nil)); end

  def filter(params); end

  private

  def compiled_filter; end
end

class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def initialize(regexps, blocks); end

  def blocks; end
  def call(original_params); end
  def regexps; end

  class << self
    def compile(filters); end
  end
end

ActionDispatch::Http::ParameterFilter::FILTERED = T.let(T.unsafe(nil), String)

module ActionDispatch::Http::Parameters
  def initialize(env); end

  def parameters; end
  def params; end
  def path_parameters; end
  def path_parameters=(parameters); end
  def reset_parameters; end
  def symbolized_path_parameters; end

  private

  def normalize_encode_params(params); end
end

module ActionDispatch::Http::URL
  def initialize(env); end

  def domain(tld_length = T.unsafe(nil)); end
  def host; end
  def host_with_port; end
  def optional_port; end
  def port; end
  def port_string; end
  def protocol; end
  def raw_host_with_port; end
  def server_port; end
  def standard_port; end
  def standard_port?; end
  def subdomain(tld_length = T.unsafe(nil)); end
  def subdomains(tld_length = T.unsafe(nil)); end
  def tld_length; end
  def tld_length=(obj); end
  def url; end

  class << self
    def extract_domain(host, tld_length = T.unsafe(nil)); end
    def extract_subdomain(host, tld_length = T.unsafe(nil)); end
    def extract_subdomains(host, tld_length = T.unsafe(nil)); end
    def tld_length; end
    def tld_length=(obj); end
    def url_for(options = T.unsafe(nil)); end

    private

    def build_host_url(options); end
    def named_host?(host); end
    def normalize_host(options); end
    def normalize_port(options); end
    def normalize_protocol(options); end
    def rewrite_authentication(options); end
    def same_host?(options); end
  end
end

ActionDispatch::Http::URL::HOST_REGEXP = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Http::URL::IP_HOST_REGEXP = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Http::URL::PROTOCOL_REGEXP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Http::UploadedFile
  def initialize(hash); end

  def close(unlink_now = T.unsafe(nil)); end
  def content_type; end
  def content_type=(_); end
  def eof?; end
  def headers; end
  def headers=(_); end
  def open; end
  def original_filename; end
  def original_filename=(_); end
  def path; end
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end
  def rewind; end
  def size; end
  def tempfile; end
  def tempfile=(_); end

  private

  def encode_filename(filename); end
end

class ActionDispatch::IllegalStateError < ::StandardError
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def delete_via_redirect(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def follow_redirect!; end
  def get(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def get_via_redirect(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def head(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def patch(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def patch_via_redirect(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def post(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def post_via_redirect(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def put(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def put_via_redirect(path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def request_via_redirect(http_method, path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def xhr(request_method, path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
  def xml_http_request(request_method, path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end
end

module ActionDispatch::Integration::Runner
  include(::ActionDispatch::Assertions::DomAssertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions::SelectorAssertions)
  include(::ActionDispatch::Assertions::TagAssertions)
  include(::ActionDispatch::Assertions)

  def app; end
  def assigns(*args); end
  def cookies(*args); end
  def copy_session_variables!; end
  def default_url_options; end
  def default_url_options=(options); end
  def delete(*args); end
  def get(*args); end
  def get_via_redirect(*args); end
  def head(*args); end
  def method_missing(sym, *args, &block); end
  def open_session(app = T.unsafe(nil)); end
  def patch(*args); end
  def post(*args); end
  def post_via_redirect(*args); end
  def put(*args); end
  def reset!; end
  def respond_to?(method, include_private = T.unsafe(nil)); end
  def xhr(*args); end
  def xml_http_request(*args); end

  private

  def integration_session; end
end

class ActionDispatch::Integration::Session
  include(::Minitest::Assertions)
  include(::ActionDispatch::Assertions::DomAssertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions::SelectorAssertions)
  include(::ActionDispatch::Assertions::TagAssertions)
  include(::ActionDispatch::Assertions)
  include(::ActionDispatch::Integration::RequestHelpers)
  include(::ActionDispatch::TestProcess)
  include(::ActionController::ModelNaming)
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  include(::ActionDispatch::Routing::UrlFor)

  def initialize(app); end

  def accept; end
  def accept=(_); end
  def body(*args, &block); end
  def controller; end
  def cookies; end
  def default_url_options; end
  def default_url_options=(_); end
  def default_url_options?; end
  def headers(*args, &block); end
  def host; end
  def host!(_); end
  def host=(_); end
  def https!(flag = T.unsafe(nil)); end
  def https?; end
  def path(*args, &block); end
  def redirect?(*args, &block); end
  def remote_addr; end
  def remote_addr=(_); end
  def request; end
  def request_count; end
  def request_count=(_); end
  def reset!; end
  def response; end
  def status(*args, &block); end
  def status_message(*args, &block); end
  def url_options; end

  private

  def _mock_session; end
  def process(method, path, parameters = T.unsafe(nil), headers_or_env = T.unsafe(nil)); end

  class << self
    def default_url_options; end
    def default_url_options=(val); end
    def default_url_options?; end
  end
end

ActionDispatch::Integration::Session::DEFAULT_HOST = T.let(T.unsafe(nil), String)

class ActionDispatch::IntegrationTest < ::ActiveSupport::TestCase
  include(::ActionDispatch::Assertions::DomAssertions)
  include(::ActionDispatch::Assertions::ResponseAssertions)
  include(::ActionDispatch::Assertions::RoutingAssertions)
  include(::ActionDispatch::Assertions::SelectorAssertions)
  include(::ActionDispatch::Assertions::TagAssertions)
  include(::ActionDispatch::Assertions)
  include(::ActionDispatch::Integration::Runner)
  include(::ActionController::TemplateAssertions)
  include(::ActionController::ModelNaming)
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  include(::ActionDispatch::Routing::UrlFor)

  def app; end
  def url_options; end

  class << self
    def _setup_callbacks; end
    def _teardown_callbacks; end
    def app; end
    def app=(app); end
  end
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Formatter
  def initialize(routes); end

  def clear; end
  def generate(type, name, options, recall = T.unsafe(nil), parameterize = T.unsafe(nil)); end
  def routes; end

  private

  def build_cache; end
  def cache; end
  def extract_parameterized_parts(route, options, recall, parameterize = T.unsafe(nil)); end
  def match_route(name, options); end
  def missing_keys(route, parts); end
  def named_routes; end
  def non_recursive(cache, options); end
  def possibles(cache, options, depth = T.unsafe(nil)); end
  def verify_required_parts!(route, parts); end
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def initialize(root); end

  def ast; end
  def endpoints; end
  def firstpos(node); end
  def followpos(node); end
  def lastpos(node); end
  def nullable?(node); end
  def root; end
  def transition_table; end

  private

  def build_followpos; end
  def followpos_table; end
  def symbol(edge); end
end

ActionDispatch::Journey::GTG::Builder::DUMMY = T.let(T.unsafe(nil), ActionDispatch::Journey::Nodes::Dummy)

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos; end
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def =~(string); end
  def match(string); end
  def simulate(string); end
  def tt; end
end

class ActionDispatch::Journey::GTG::TransitionTable
  include(::ActionDispatch::Journey::NFA::Dot)

  def initialize; end

  def []=(from, to, sym); end
  def accepting?(state); end
  def accepting_states; end
  def add_accepting(state); end
  def add_memo(idx, memo); end
  def as_json(options = T.unsafe(nil)); end
  def eclosure(t); end
  def memo(idx); end
  def memos; end
  def move(t, a); end
  def states; end
  def to_svg; end
  def transitions; end
  def visualizer(paths, title = T.unsafe(nil)); end

  private

  def move_regexp(t, a); end
  def move_string(t, a); end
  def states_hash_for(sym); end
end

module ActionDispatch::Journey::NFA
end

class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end

  def transition_table; end
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot; end
end

class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end

  def memos; end
end

class ActionDispatch::Journey::NFA::Simulator
  def initialize(transition_table); end

  def =~(string); end
  def match(string); end
  def simulate(string); end
  def tt; end
end

class ActionDispatch::Journey::NFA::TransitionTable
  include(::ActionDispatch::Journey::NFA::Dot)

  def initialize; end

  def []=(i, f, s); end
  def accepting; end
  def accepting=(_); end
  def accepting?(state); end
  def accepting_states; end
  def add_memo(idx, memo); end
  def alphabet; end
  def eclosure(t); end
  def following_states(t, a); end
  def generalized_table; end
  def memo(idx); end
  def memos; end
  def merge(left, right); end
  def move(t, a); end
  def states; end
  def transitions; end

  private

  def inverted; end
end

class ActionDispatch::Journey::NFA::Visitor < ::ActionDispatch::Journey::Visitors::Visitor
  def initialize(tt); end

  def terminal(node); end
  def visit_CAT(node); end
  def visit_GROUP(node); end
  def visit_OR(node); end
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary < ::ActionDispatch::Journey::Nodes::Node
  def initialize(left, right); end

  def children; end
  def right; end
  def right=(_); end
end

class ActionDispatch::Journey::Nodes::Cat < ::ActionDispatch::Journey::Nodes::Binary
  def type; end
end

class ActionDispatch::Journey::Nodes::Dot < ::ActionDispatch::Journey::Nodes::Terminal
  def type; end
end

class ActionDispatch::Journey::Nodes::Dummy < ::ActionDispatch::Journey::Nodes::Literal
  def initialize(x = T.unsafe(nil)); end

  def literal?; end
end

class ActionDispatch::Journey::Nodes::Group < ::ActionDispatch::Journey::Nodes::Unary
  def type; end
end

class ActionDispatch::Journey::Nodes::Literal < ::ActionDispatch::Journey::Nodes::Terminal
  def literal?; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Node
  include(::Enumerable)

  def initialize(left); end

  def each(&block); end
  def left; end
  def left=(_); end
  def literal?; end
  def memo; end
  def memo=(_); end
  def name; end
  def symbol?; end
  def to_dot; end
  def to_s; end
  def to_sym; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Or < ::ActionDispatch::Journey::Nodes::Node
  def initialize(children); end

  def children; end
  def type; end
end

class ActionDispatch::Journey::Nodes::Slash < ::ActionDispatch::Journey::Nodes::Terminal
  def type; end
end

class ActionDispatch::Journey::Nodes::Star < ::ActionDispatch::Journey::Nodes::Unary
  def type; end
end

class ActionDispatch::Journey::Nodes::Symbol < ::ActionDispatch::Journey::Nodes::Terminal
  def initialize(left); end

  def default_regexp?; end
  def regexp; end
  def regexp=(_); end
  def symbol; end
  def symbol?; end
  def type; end
end

ActionDispatch::Journey::Nodes::Symbol::DEFAULT_EXP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Journey::Nodes::Terminal < ::ActionDispatch::Journey::Nodes::Node
  def symbol; end
end

class ActionDispatch::Journey::Nodes::Unary < ::ActionDispatch::Journey::Nodes::Node
  def children; end
end

class ActionDispatch::Journey::Parser < ::Racc::Parser
  include(::ActionDispatch::Journey::Nodes)

  def initialize; end

  def _reduce_1(val, _values, result); end
  def _reduce_14(val, _values, result); end
  def _reduce_15(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_17(val, _values, result); end
  def _reduce_2(val, _values, result); end
  def _reduce_7(val, _values, result); end
  def _reduce_8(val, _values, result); end
  def _reduce_9(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def next_token; end
  def parse(string); end
end

ActionDispatch::Journey::Parser::Racc_arg = T.let(T.unsafe(nil), Array)

ActionDispatch::Journey::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def initialize(strexp); end

  def =~(other); end
  def anchored; end
  def ast; end
  def match(other); end
  def names; end
  def optional_names; end
  def required_names; end
  def requirements; end
  def source; end
  def spec; end
  def to_regexp; end

  private

  def offsets; end
  def regexp_visitor; end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp < ::ActionDispatch::Journey::Visitors::Visitor
  def initialize(separator, matchers); end

  def accept(node); end
  def visit_CAT(node); end
  def visit_DOT(node); end
  def visit_GROUP(node); end
  def visit_LITERAL(node); end
  def visit_SLASH(node); end
  def visit_STAR(node); end
  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def initialize(names, offsets, match); end

  def [](x); end
  def captures; end
  def length; end
  def names; end
  def post_match; end
  def to_s; end
end

class ActionDispatch::Journey::Path::Pattern::RegexpOffsets < ::ActionDispatch::Journey::Visitors::Visitor
  def initialize(matchers); end

  def offsets; end
  def visit(node); end
  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp < ::ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def accept(node); end
end

class ActionDispatch::Journey::Route
  def initialize(name, app, path, constraints, defaults = T.unsafe(nil)); end

  def app; end
  def ast; end
  def conditions; end
  def constraints; end
  def defaults; end
  def dispatcher?; end
  def format(path_options); end
  def ip; end
  def matches?(request); end
  def name; end
  def optimized_path; end
  def optional_parts; end
  def parts; end
  def path; end
  def precedence; end
  def precedence=(_); end
  def required_default?(key); end
  def required_defaults; end
  def required_keys; end
  def required_parts; end
  def requirements; end
  def score(constraints); end
  def segment_keys; end
  def segments; end
  def verb; end
end

class ActionDispatch::Journey::Router
  def initialize(routes, options); end

  def call(env); end
  def formatter; end
  def recognize(req); end
  def request_class; end
  def routes; end
  def routes=(_); end
  def visualizer; end

  private

  def ast; end
  def custom_routes; end
  def filter_routes(path); end
  def find_routes(env); end
  def get_routes_as_head(routes); end
  def partitioned_routes; end
  def simulator; end
end

class ActionDispatch::Journey::Router::NullReq
  def initialize(env); end

  def [](k); end
  def env; end
  def ip; end
  def path_info; end
  def request_method; end
end

class ActionDispatch::Journey::Router::RoutingError < ::StandardError
end

class ActionDispatch::Journey::Router::Strexp
  def initialize(path, requirements, separators, anchor = T.unsafe(nil)); end

  def anchor; end
  def names; end
  def path; end
  def requirements; end
  def separators; end

  class << self
    def compile(*_); end
  end
end

class ActionDispatch::Journey::Router::Utils
  class << self
    def escape_fragment(fragment); end
    def escape_path(path); end
    def normalize_path(path); end
    def unescape_uri(uri); end
  end
end

ActionDispatch::Journey::Router::Utils::Parser = T.let(T.unsafe(nil), URI::RFC2396_Parser)

module ActionDispatch::Journey::Router::Utils::UriEscape
end

ActionDispatch::Journey::Router::Utils::UriEscape::UNSAFE_FRAGMENT = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Journey::Router::Utils::UriEscape::UNSAFE_SEGMENT = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Journey::Router::VERSION = T.let(T.unsafe(nil), String)

class ActionDispatch::Journey::Routes
  include(::Enumerable)

  def initialize; end

  def add_route(app, path, conditions, defaults, name = T.unsafe(nil)); end
  def ast; end
  def clear; end
  def each(&block); end
  def last; end
  def length; end
  def named_routes; end
  def partitioned_routes; end
  def routes; end
  def simulator; end
  def size; end

  private

  def clear_cache!; end
end

class ActionDispatch::Journey::Scanner
  def initialize; end

  def eos?; end
  def next_token; end
  def pos; end
  def pre_match; end
  def scan_setup(str); end

  private

  def scan; end
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot < ::ActionDispatch::Journey::Visitors::Visitor
  def initialize; end

  def accept(node); end

  private

  def binary(node); end
  def nary(node); end
  def terminal(node); end
  def unary(node); end
  def visit_CAT(node); end
  def visit_GROUP(node); end
  def visit_OR(node); end
  def visit_STAR(node); end
end

class ActionDispatch::Journey::Visitors::Each < ::ActionDispatch::Journey::Visitors::Visitor
  def initialize(block); end

  def block; end
  def visit(node); end
end

class ActionDispatch::Journey::Visitors::Formatter < ::ActionDispatch::Journey::Visitors::Visitor
  def initialize(options); end

  def options; end

  private

  def visit(node, optional = T.unsafe(nil)); end
  def visit_CAT(node, optional); end
  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Visitors::OptimizedPath < ::ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  def visit_DOT(n); end
  def visit_LITERAL(n); end
  def visit_SLASH(n); end

  private

  def visit_CAT(node); end
  def visit_GROUP(node); end
  def visit_STAR(node); end
  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Visitors::String < ::ActionDispatch::Journey::Visitors::Visitor

  private

  def binary(node); end
  def nary(node); end
  def terminal(node); end
  def visit_GROUP(node); end
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  def visit_DOT(n); end
  def visit_LITERAL(n); end
  def visit_SLASH(n); end
  def visit_SYMBOL(n); end

  private

  def binary(node); end
  def nary(node); end
  def terminal(node); end
  def unary(node); end
  def visit(node); end
  def visit_CAT(n); end
  def visit_GROUP(n); end
  def visit_OR(n); end
  def visit_STAR(n); end
end

ActionDispatch::Journey::Visitors::Visitor::DISPATCH_CACHE = T.let(T.unsafe(nil), ThreadSafe::Cache)

class ActionDispatch::MiddlewareStack
  include(::Enumerable)

  def initialize(*args); end

  def [](i); end
  def build(app = T.unsafe(nil), &block); end
  def delete(target); end
  def each; end
  def insert(index, *args, &block); end
  def insert_after(index, *args, &block); end
  def insert_before(index, *args, &block); end
  def last; end
  def middlewares; end
  def middlewares=(_); end
  def size; end
  def swap(target, *args, &block); end
  def unshift(*args, &block); end
  def use(*args, &block); end

  protected

  def assert_index(index, where); end

  private

  def initialize_copy(other); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def initialize(klass_or_name, *args, &block); end

  def ==(middleware); end
  def args; end
  def block; end
  def build(app); end
  def classcache; end
  def inspect; end
  def klass; end
  def name; end

  private

  def normalize(object); end
end

class ActionDispatch::ParamsParser
  def initialize(app, parsers = T.unsafe(nil)); end

  def call(env); end

  private

  def logger(env); end
  def parse_formatted_parameters(env); end
end

ActionDispatch::ParamsParser::DEFAULT_PARSERS = T.let(T.unsafe(nil), Hash)

class ActionDispatch::ParamsParser::ParseError < ::StandardError
  def initialize(message, original_exception); end

  def original_exception; end
end

class ActionDispatch::PublicExceptions
  def initialize(public_path); end

  def call(env); end
  def public_path; end
  def public_path=(_); end

  private

  def render(status, content_type, body); end
  def render_format(status, content_type, body); end
  def render_html(status); end
end

class ActionDispatch::Railtie < ::Rails::Railtie
end

class ActionDispatch::Reloader
  include(::ActiveSupport::Callbacks)
  include(::ActiveSupport::Deprecation::Reporting)
  extend(::ActiveSupport::Callbacks::ClassMethods)
  extend(::ActiveSupport::DescendantsTracker)

  def initialize(app, condition = T.unsafe(nil)); end

  def _cleanup_callbacks; end
  def _cleanup_callbacks=(_); end
  def _cleanup_callbacks?; end
  def _prepare_callbacks; end
  def _prepare_callbacks=(_); end
  def _prepare_callbacks?; end
  def call(env); end
  def cleanup!; end
  def prepare!; end

  private

  def validated?; end

  class << self
    def _cleanup_callbacks; end
    def _cleanup_callbacks=(val); end
    def _cleanup_callbacks?; end
    def _prepare_callbacks; end
    def _prepare_callbacks=(val); end
    def _prepare_callbacks?; end
    def cleanup!; end
    def prepare!; end
    def to_cleanup(*args, &block); end
    def to_prepare(*args, &block); end
  end
end

class ActionDispatch::RemoteIp
  def initialize(app, check_ip_spoofing = T.unsafe(nil), custom_proxies = T.unsafe(nil)); end

  def call(env); end
  def check_ip; end
  def proxies; end
end

class ActionDispatch::RemoteIp::GetIp
  def initialize(env, middleware); end

  def calculate_ip; end
  def to_s; end

  protected

  def filter_proxies(ips); end
  def ips_from(header); end
end

ActionDispatch::RemoteIp::GetIp::VALID_IP = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::RemoteIp::IpSpoofAttackError < ::StandardError
end

ActionDispatch::RemoteIp::TRUSTED_PROXIES = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Request < ::Rack::Request
  include(::ActionDispatch::Http::Cache::Request)
  include(::ActionDispatch::Http::MimeNegotiation)
  include(::ActionDispatch::Http::Parameters)
  include(::ActionDispatch::Http::FilterParameters)
  include(::ActionDispatch::Http::URL)

  def initialize(env); end

  def GET; end
  def POST; end
  def accept; end
  def accept_charset; end
  def accept_encoding; end
  def accept_language; end
  def auth_type; end
  def authorization; end
  def body; end
  def body_stream; end
  def cache_control; end
  def content_length; end
  def cookie_jar; end
  def deep_munge(hash); end
  def delete?; end
  def flash; end
  def form_data?; end
  def from; end
  def fullpath; end
  def gateway_interface; end
  def get?; end
  def head?; end
  def headers; end
  def ignore_accept_header; end
  def ignore_accept_header=(obj); end
  def ip; end
  def key?(key); end
  def local?; end
  def media_type; end
  def method; end
  def method_symbol; end
  def negotiate; end
  def original_fullpath; end
  def original_url; end
  def patch?; end
  def path_translated; end
  def post?; end
  def pragma; end
  def put?; end
  def query_parameters; end
  def raw_post; end
  def remote_addr; end
  def remote_host; end
  def remote_ident; end
  def remote_ip; end
  def remote_user; end
  def request_method; end
  def request_method_symbol; end
  def request_parameters; end
  def reset_session; end
  def server_name; end
  def server_protocol; end
  def server_software; end
  def session=(session); end
  def session_options=(options); end
  def uuid; end
  def xhr?; end
  def xml_http_request?; end

  protected

  def parse_query(qs); end

  private

  def check_method(name); end

  class << self
    def ignore_accept_header; end
    def ignore_accept_header=(obj); end
  end
end

ActionDispatch::Request::ENV_METHODS = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::HTTP_METHODS = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::HTTP_METHOD_LOOKUP = T.let(T.unsafe(nil), Hash)

ActionDispatch::Request::LOCALHOST = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Request::RFC2518 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC2616 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC3253 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC3648 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC3744 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC5323 = T.let(T.unsafe(nil), Array)

ActionDispatch::Request::RFC5789 = T.let(T.unsafe(nil), Array)

class ActionDispatch::Request::Session
  def initialize(by, env); end

  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def destroy; end
  def empty?; end
  def exists?; end
  def fetch(key, default = T.unsafe(nil), &block); end
  def has_key?(key); end
  def id; end
  def include?(key); end
  def inspect; end
  def key?(key); end
  def keys; end
  def loaded?; end
  def merge!(other); end
  def options; end
  def to_hash; end
  def update(hash); end
  def values; end

  private

  def load!; end
  def load_for_read!; end
  def load_for_write!; end
  def stringify_keys(other); end

  class << self
    def create(store, env, default_options); end
    def find(env); end
    def set(env, session); end
  end
end

ActionDispatch::Request::Session::ENV_SESSION_KEY = T.let(T.unsafe(nil), String)

ActionDispatch::Request::Session::ENV_SESSION_OPTIONS_KEY = T.let(T.unsafe(nil), String)

class ActionDispatch::Request::Session::Options
  def initialize(by, env, default_options); end

  def [](key); end
  def []=(k, v); end
  def to_hash; end
  def values_at(*args); end

  class << self
    def find(env); end
    def set(env, options); end
  end
end

ActionDispatch::Request::Session::Unspecified = T.let(T.unsafe(nil), Object)

class ActionDispatch::Request::Utils
  def perform_deep_munge; end
  def perform_deep_munge=(obj); end

  class << self
    def deep_munge(hash, keys = T.unsafe(nil)); end
    def perform_deep_munge; end
    def perform_deep_munge=(obj); end
  end
end

class ActionDispatch::RequestId
  def initialize(app); end

  def call(env); end

  private

  def external_request_id(env); end
  def internal_request_id; end
end

class ActionDispatch::Response
  include(::Rack::Response::Helpers)
  include(::ActionDispatch::Http::FilterRedirect)
  include(::ActionDispatch::Http::Cache::Response)
  include(::MonitorMixin)

  def initialize(status = T.unsafe(nil), header = T.unsafe(nil), body = T.unsafe(nil)); end

  def [](*args, &block); end
  def []=(*args, &block); end
  def await_commit; end
  def await_sent; end
  def body; end
  def body=(body); end
  def body_parts; end
  def charset; end
  def charset=(_); end
  def close; end
  def code; end
  def commit!; end
  def committed?; end
  def content_type; end
  def content_type=(content_type); end
  def cookies; end
  def default_charset; end
  def default_charset=(obj); end
  def default_headers; end
  def default_headers=(obj); end
  def delete_cookie(key, value = T.unsafe(nil)); end
  def each(*args, &block); end
  def header; end
  def header=(_); end
  def headers; end
  def headers=(_); end
  def location; end
  def location=(url); end
  def message; end
  def prepare!; end
  def redirect_url; end
  def request; end
  def request=(_); end
  def respond_to?(method, include_private = T.unsafe(nil)); end
  def response_code; end
  def sending!; end
  def sending?; end
  def sending_file=(_); end
  def sent!; end
  def sent?; end
  def set_cookie(key, value); end
  def status; end
  def status=(status); end
  def status_message; end
  def stream; end
  def to_a; end
  def to_ary; end
  def to_path; end

  private

  def append_charset?; end
  def assign_default_content_type_and_charset!(headers); end
  def before_committed; end
  def before_sending; end
  def build_buffer(response, body); end
  def merge_default_headers(original, default); end
  def munge_body_object(body); end
  def rack_response(status, header); end

  class << self
    def default_charset; end
    def default_charset=(obj); end
    def default_headers; end
    def default_headers=(obj); end
  end
end

class ActionDispatch::Response::Buffer
  def initialize(response, buf); end

  def close; end
  def closed?; end
  def each(&block); end
  def write(string); end
end

ActionDispatch::Response::CONTENT_TYPE = T.let(T.unsafe(nil), String)

ActionDispatch::Response::EMPTY = T.let(T.unsafe(nil), String)

ActionDispatch::Response::LOCATION = T.let(T.unsafe(nil), String)

ActionDispatch::Response::NO_CONTENT_CODES = T.let(T.unsafe(nil), Array)

ActionDispatch::Response::SET_COOKIE = T.let(T.unsafe(nil), String)

module ActionDispatch::Routing
  extend(::ActiveSupport::Autoload)
end

class ActionDispatch::Routing::ConsoleFormatter
  def initialize; end

  def header(routes); end
  def no_routes; end
  def result; end
  def section(routes); end
  def section_title(title); end

  private

  def draw_header(routes); end
  def draw_section(routes); end
  def widths(routes); end
end

ActionDispatch::Routing::HTTP_METHODS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::HtmlTableFormatter
  def initialize(view); end

  def header(routes); end
  def no_routes; end
  def result; end
  def section(routes); end
  def section_title(title); end
end

class ActionDispatch::Routing::Mapper
  include(::ActionDispatch::Routing::Mapper::Base)
  include(::ActionDispatch::Routing::Mapper::HttpHelpers)
  include(::ActionDispatch::Routing::Redirection)
  include(::ActionDispatch::Routing::Mapper::Scoping)
  include(::ActionDispatch::Routing::Mapper::Concerns)
  include(::ActionDispatch::Routing::Mapper::Resources)

  def initialize(set); end

  class << self
    def normalize_name(name); end
    def normalize_path(path); end
  end
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end
  def default_url_options=(options); end
  def has_named_route?(name); end
  def match(path, options = T.unsafe(nil)); end
  def mount(app, options = T.unsafe(nil)); end
  def root(options = T.unsafe(nil)); end
  def with_default_scope(scope, &block); end

  private

  def app_name(app); end
  def define_generate_prefix(app, name); end
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable = T.unsafe(nil), &block); end
  def concerns(*args); end
end

class ActionDispatch::Routing::Mapper::Constraints
  def initialize(app, constraints, request); end

  def app; end
  def call(env); end
  def constraints; end
  def matches?(env); end

  private

  def constraint_args(constraint, request); end

  class << self
    def new(app, constraints, request = T.unsafe(nil)); end
  end
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  def delete(*args, &block); end
  def get(*args, &block); end
  def patch(*args, &block); end
  def post(*args, &block); end
  def put(*args, &block); end

  private

  def map_method(method, args, &block); end
end

class ActionDispatch::Routing::Mapper::Mapping
  def initialize(set, scope, path, options); end

  def conditions; end
  def defaults; end
  def options; end
  def path; end
  def requirements; end
  def scope; end
  def to_route; end

  private

  def app; end
  def blocks; end
  def constraints; end
  def default_action; end
  def default_controller; end
  def default_controller_and_action; end
  def dispatcher; end
  def endpoint; end
  def normalize_conditions!; end
  def normalize_defaults!; end
  def normalize_options!; end
  def normalize_path!; end
  def normalize_requirements!; end
  def optional_format?; end
  def path_pattern; end
  def required_format?; end
  def segment_keys; end
  def strexp; end
  def to; end
  def verify_regexp_requirement(requirement); end
end

ActionDispatch::Routing::Mapper::Mapping::ANCHOR_CHARACTERS_REGEX = T.let(T.unsafe(nil), Regexp)

ActionDispatch::Routing::Mapper::Mapping::IGNORE_OPTIONS = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::Mapping::WILDCARD_PATH = T.let(T.unsafe(nil), Regexp)

module ActionDispatch::Routing::Mapper::Resources
  def add_route(action, options); end
  def collection; end
  def decomposed_match(path, options); end
  def match(path, *rest); end
  def member; end
  def namespace(path, options = T.unsafe(nil)); end
  def nested; end
  def new; end
  def resource(*resources, &block); end
  def resources(*resources, &block); end
  def resources_path_names(options); end
  def root(path, options = T.unsafe(nil)); end
  def shallow; end
  def shallow?; end
  def using_match_shorthand?(path, options); end

  protected

  def action_options?(options); end
  def action_path(name, path = T.unsafe(nil)); end
  def apply_common_behavior_for(method, resources, options, &block); end
  def canonical_action?(action, flag); end
  def name_for_action(as, action); end
  def nested_options; end
  def nesting_depth; end
  def param_constraint; end
  def param_constraint?; end
  def parent_resource; end
  def path_for_action(action, path); end
  def prefix_name_for_action(as, action); end
  def resource_method_scope?; end
  def resource_scope(kind, resource); end
  def resource_scope?; end
  def scope_action_options; end
  def scope_action_options?; end
  def set_member_mappings_for_resource; end
  def shallow_scope(path, options = T.unsafe(nil)); end
  def with_exclusive_scope; end
  def with_scope_level(kind); end
end

ActionDispatch::Routing::Mapper::Resources::CANONICAL_ACTIONS = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::Resources::RESOURCE_METHOD_SCOPES = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::Resources::RESOURCE_OPTIONS = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::Resources::RESOURCE_SCOPES = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::Mapper::Resources::Resource
  def initialize(entities, options = T.unsafe(nil)); end

  def actions; end
  def collection_name; end
  def collection_scope; end
  def controller; end
  def default_actions; end
  def member_name; end
  def member_scope; end
  def name; end
  def nested_param; end
  def nested_scope; end
  def new_scope(new_path); end
  def options; end
  def param; end
  def path; end
  def plural; end
  def resource_scope; end
  def shallow_scope; end
  def singular; end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource < ::ActionDispatch::Routing::Mapper::Resources::Resource
  def initialize(entities, options); end

  def collection_name; end
  def default_actions; end
  def member_name; end
  def member_scope; end
  def nested_scope; end
  def plural; end
  def singular; end
end

ActionDispatch::Routing::Mapper::Resources::VALID_ON_OPTIONS = T.let(T.unsafe(nil), Array)

ActionDispatch::Routing::Mapper::SCOPE_OPTIONS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints = T.unsafe(nil)); end
  def controller(controller, options = T.unsafe(nil)); end
  def defaults(defaults = T.unsafe(nil)); end
  def namespace(path, options = T.unsafe(nil)); end
  def scope(*args); end

  private

  def merge_action_scope(parent, child); end
  def merge_as_scope(parent, child); end
  def merge_blocks_scope(parent, child); end
  def merge_constraints_scope(parent, child); end
  def merge_controller_scope(parent, child); end
  def merge_defaults_scope(parent, child); end
  def merge_module_scope(parent, child); end
  def merge_options_scope(parent, child); end
  def merge_path_names_scope(parent, child); end
  def merge_path_scope(parent, child); end
  def merge_shallow_path_scope(parent, child); end
  def merge_shallow_prefix_scope(parent, child); end
  def merge_shallow_scope(parent, child); end
  def override_keys(child); end
end

ActionDispatch::Routing::Mapper::URL_OPTIONS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Routing::PolymorphicRoutes
  include(::ActionController::ModelNaming)

  def edit_polymorphic_path(record_or_hash, options = T.unsafe(nil)); end
  def edit_polymorphic_url(record_or_hash, options = T.unsafe(nil)); end
  def new_polymorphic_path(record_or_hash, options = T.unsafe(nil)); end
  def new_polymorphic_url(record_or_hash, options = T.unsafe(nil)); end
  def polymorphic_path(record_or_hash_or_array, options = T.unsafe(nil)); end
  def polymorphic_url(record_or_hash_or_array, options = T.unsafe(nil)); end

  private

  def action_prefix(options); end
  def build_named_route_call(records, inflection, options = T.unsafe(nil)); end
  def extract_record(record_or_hash_or_array); end
  def routing_type(options); end
end

class ActionDispatch::Routing::RouteSet
  def initialize(request_class = T.unsafe(nil)); end

  def _generate_prefix(options = T.unsafe(nil)); end
  def add_route(app, conditions = T.unsafe(nil), requirements = T.unsafe(nil), defaults = T.unsafe(nil), name = T.unsafe(nil), anchor = T.unsafe(nil)); end
  def append(&block); end
  def call(env); end
  def clear!; end
  def default_scope; end
  def default_scope=(_); end
  def default_url_options; end
  def default_url_options=(_); end
  def define_mounted_helper(name); end
  def disable_clear_and_finalize; end
  def disable_clear_and_finalize=(_); end
  def draw(&block); end
  def empty?; end
  def eval_block(block); end
  def extra_keys(options, recall = T.unsafe(nil)); end
  def finalize!; end
  def formatter; end
  def formatter=(_); end
  def generate(options, recall = T.unsafe(nil)); end
  def generate_extras(options, recall = T.unsafe(nil)); end
  def inspect; end
  def mounted?; end
  def mounted_helpers; end
  def named_routes; end
  def named_routes=(_); end
  def optimize_routes_generation?; end
  def prepend(&block); end
  def recognize_path(path, environment = T.unsafe(nil)); end
  def request_class; end
  def request_class=(_); end
  def resources_path_names; end
  def resources_path_names=(_); end
  def router; end
  def router=(_); end
  def routes; end
  def set; end
  def set=(_); end
  def url_for(options); end
  def url_helpers; end

  private

  def build_conditions(current_conditions, path_values); end
  def build_path(path, requirements, separators, anchor); end
  def extract_authentication(options); end

  class << self
    def default_resources_path_names; end
  end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(options = T.unsafe(nil)); end

  def call(env); end
  def controller(params, default_controller = T.unsafe(nil)); end
  def prepare_params!(params); end

  private

  def controller_reference(controller_param); end
  def dispatch(controller, action, env); end
  def merge_default_action!(params); end
  def normalize_controller!(params); end
  def split_glob_param!(params); end
end

class ActionDispatch::Routing::RouteSet::Generator
  def initialize(options, recall, set); end

  def controller; end
  def current_controller; end
  def different_controller?; end
  def generate; end
  def named_route; end
  def normalize_action!; end
  def normalize_controller!; end
  def normalize_controller_action_id!; end
  def normalize_options!; end
  def normalize_recall!; end
  def options; end
  def recall; end
  def set; end
  def use_recall_for(key); end
  def use_relative_controller!; end

  private

  def named_route_exists?; end
  def segment_keys; end
end

ActionDispatch::Routing::RouteSet::Generator::PARAMETERIZE = T.let(T.unsafe(nil), Proc)

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend(::ActiveSupport::Concern)

  include(::ActionDispatch::Routing::UrlFor)
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include(::Enumerable)

  def initialize; end

  def [](name); end
  def []=(name, route); end
  def add(name, route); end
  def clear; end
  def clear!; end
  def each; end
  def get(name); end
  def helper_names; end
  def helpers; end
  def length; end
  def module; end
  def names; end
  def routes; end

  private

  def define_named_route_methods(name, route); end
  def define_url_helper(route, name, options); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def initialize(route, options); end

  def call(t, args); end
  def handle_positional_args(t, args, options, keys); end

  class << self
    def create(route, options); end
    def optimize_helper?(route); end
  end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper < ::ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def initialize(route, options); end

  def arg_size; end
  def call(t, args); end

  private

  def missing_keys(args); end
  def optimize_routes_generation?(t); end
  def optimized_helper(args); end
  def parameterize_args(args); end
  def raise_generation_error(args, missing_keys); end
  def replace_segment(params, segment); end
end

ActionDispatch::Routing::RouteSet::PARAMETERS_KEY = T.let(T.unsafe(nil), String)

ActionDispatch::Routing::RouteSet::RESERVED_OPTIONS = T.let(T.unsafe(nil), Array)

class ActionDispatch::Routing::RouteWrapper < ::SimpleDelegator
  def action; end
  def constraints; end
  def controller; end
  def endpoint; end
  def engine?; end
  def internal?; end
  def json_regexp; end
  def name; end
  def path; end
  def rack_app(app = T.unsafe(nil)); end
  def regexp; end
  def reqs; end
  def verb; end
end

class ActionDispatch::Routing::RoutesInspector
  def initialize(routes); end

  def format(formatter, filter = T.unsafe(nil)); end

  private

  def collect_engine_routes(route); end
  def collect_routes(routes); end
  def filter_routes(filter); end
end

class ActionDispatch::Routing::RoutesProxy
  include(::ActionController::ModelNaming)
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  include(::ActionDispatch::Routing::UrlFor)

  def initialize(routes, scope); end

  def _routes; end
  def default_url_options; end
  def default_url_options=(_); end
  def default_url_options?; end
  def method_missing(method, *args); end
  def respond_to?(method, include_private = T.unsafe(nil)); end
  def routes; end
  def routes=(_); end
  def scope; end
  def scope=(_); end
  def url_options; end

  class << self
    def default_url_options; end
    def default_url_options=(val); end
    def default_url_options?; end
  end
end

ActionDispatch::Routing::SEPARATORS = T.let(T.unsafe(nil), Array)

module ActionDispatch::Routing::UrlFor
  include(::ActionController::ModelNaming)
  include(::ActionDispatch::Routing::PolymorphicRoutes)
  extend(::ActiveSupport::Concern)

  def initialize(*_); end

  def url_for(options = T.unsafe(nil)); end
  def url_options; end

  protected

  def _routes_context; end
  def _with_routes(routes); end
  def optimize_routes_generation?; end
end

class ActionDispatch::SSL
  def initialize(app, options = T.unsafe(nil)); end

  def call(env); end

  private

  def flag_cookies_as_secure!(headers); end
  def hsts_headers; end
  def redirect_to_https(request); end

  class << self
    def default_hsts_options; end
  end
end

ActionDispatch::SSL::YEAR = T.let(T.unsafe(nil), Fixnum)

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractStore < ::Rack::Session::Abstract::ID
  include(::ActionDispatch::Session::Compatibility)
  include(::ActionDispatch::Session::StaleSessionCheck)
  include(::ActionDispatch::Session::SessionObject)


  private

  def set_cookie(env, session_id, cookie); end
end

class ActionDispatch::Session::CacheStore < ::ActionDispatch::Session::AbstractStore
  def initialize(app, options = T.unsafe(nil)); end

  def destroy_session(env, sid, options); end
  def get_session(env, sid); end
  def set_session(env, sid, session, options); end

  private

  def cache_key(sid); end
end

module ActionDispatch::Session::Compatibility
  def initialize(app, options = T.unsafe(nil)); end

  def generate_sid; end

  protected

  def initialize_sid; end
end

class ActionDispatch::Session::CookieStore < ::Rack::Session::Abstract::ID
  include(::ActionDispatch::Session::Compatibility)
  include(::ActionDispatch::Session::StaleSessionCheck)
  include(::ActionDispatch::Session::SessionObject)

  def initialize(app, options = T.unsafe(nil)); end

  def destroy_session(env, session_id, options); end
  def load_session(env); end

  private

  def cookie_jar(env); end
  def extract_session_id(env); end
  def get_cookie(env); end
  def persistent_session_id!(data, sid = T.unsafe(nil)); end
  def set_cookie(env, session_id, cookie); end
  def set_session(env, sid, session_data, options); end
  def unpacked_cookie_data(env); end
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end
  def prepare_session(env); end
end

class ActionDispatch::Session::SessionRestoreError < ::StandardError
  def initialize(const_error); end

  def original_exception; end
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end
  def load_session(env); end
  def stale_session_check!; end
end

class ActionDispatch::ShowExceptions
  def initialize(app, exceptions_app); end

  def call(env); end

  private

  def pass_response(status); end
  def render_exception(env, exception); end
end

ActionDispatch::ShowExceptions::FAILSAFE_RESPONSE = T.let(T.unsafe(nil), Array)

class ActionDispatch::Static
  def initialize(app, path, cache_control = T.unsafe(nil)); end

  def call(env); end
end

module ActionDispatch::TestProcess
  def assigns(key = T.unsafe(nil)); end
  def cookies; end
  def fixture_file_upload(path, mime_type = T.unsafe(nil), binary = T.unsafe(nil)); end
  def flash; end
  def redirect_to_url; end
  def session; end
end

class ActionDispatch::TestRequest < ::ActionDispatch::Request
  def initialize(env = T.unsafe(nil)); end

  def accept=(mime_types); end
  def action=(action_name); end
  def cookies; end
  def host=(host); end
  def if_modified_since=(last_modified); end
  def if_none_match=(etag); end
  def path=(path); end
  def port=(number); end
  def rack_cookies; end
  def remote_addr=(addr); end
  def request_method=(method); end
  def request_uri=(uri); end
  def user_agent=(user_agent); end

  private

  def default_env; end

  class << self
    def new(env = T.unsafe(nil)); end
  end
end

ActionDispatch::TestRequest::DEFAULT_ENV = T.let(T.unsafe(nil), Hash)

class ActionDispatch::TestResponse < ::ActionDispatch::Response
  def error?; end
  def missing?; end
  def redirect?; end
  def success?; end

  class << self
    def from_response(response); end
  end
end

class ActionDispatch::FileHandler
  def initialize(root, cache_control); end

  def call(env); end
  def escape_glob_chars(path); end
  def ext; end
  def match?(path); end
  def unescape_path(path); end
end

class ActionDispatch::Routing::OptionRedirect < ::ActionDispatch::Routing::Redirect
  def inspect; end
  def options; end
  def path(params, request); end
end

class ActionDispatch::Routing::PathRedirect < ::ActionDispatch::Routing::Redirect
  def inspect; end
  def path(params, request); end

  private

  def interpolation_required?(string, params); end
end

ActionDispatch::Routing::PathRedirect::URL_PARTS = T.let(T.unsafe(nil), Regexp)

class ActionDispatch::Routing::Redirect
  def initialize(status, block); end

  def block; end
  def call(env); end
  def inspect; end
  def path(params, request); end
  def status; end

  private

  def escape(params); end
  def escape_fragment(params); end
  def escape_path(params); end
  def relative_path?(path); end
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionPack
  class << self
    def gem_version; end
    def version; end
  end
end

module ActionPack::VERSION
end

ActionPack::VERSION::MAJOR = T.let(T.unsafe(nil), Fixnum)

ActionPack::VERSION::MINOR = T.let(T.unsafe(nil), Fixnum)

ActionPack::VERSION::STRING = T.let(T.unsafe(nil), String)

ActionPack::VERSION::TINY = T.let(T.unsafe(nil), Fixnum)

module Mime
  class << self
    def [](type); end
    def fetch(type); end
  end
end

Mime::ALL = T.let(T.unsafe(nil), Mime::Type)

Mime::ATOM = T.let(T.unsafe(nil), Mime::Type)

Mime::BMP = T.let(T.unsafe(nil), Mime::Type)

Mime::CSS = T.let(T.unsafe(nil), Mime::Type)

Mime::CSV = T.let(T.unsafe(nil), Mime::Type)

Mime::EXTENSION_LOOKUP = T.let(T.unsafe(nil), Hash)

Mime::GIF = T.let(T.unsafe(nil), Mime::Type)

Mime::HTML = T.let(T.unsafe(nil), Mime::Type)

Mime::ICS = T.let(T.unsafe(nil), Mime::Type)

Mime::JPEG = T.let(T.unsafe(nil), Mime::Type)

Mime::JS = T.let(T.unsafe(nil), Mime::Type)

Mime::JSON = T.let(T.unsafe(nil), Mime::Type)

Mime::LOOKUP = T.let(T.unsafe(nil), Hash)

Mime::MPEG = T.let(T.unsafe(nil), Mime::Type)

Mime::MULTIPART_FORM = T.let(T.unsafe(nil), Mime::Type)

class Mime::Mimes < ::Array
  def <<(*_); end
  def []=(*_); end
  def clear(*_); end
  def collect!(*_); end
  def compact!(*_); end
  def concat(*_); end
  def delete(*_); end
  def delete_at(*_); end
  def delete_if(*_); end
  def flatten!(*_); end
  def insert(*_); end
  def map!(*_); end
  def pop(*_); end
  def push(*_); end
  def reject!(*_); end
  def replace(*_); end
  def reverse!(*_); end
  def shift(*_); end
  def slice!(*_); end
  def sort!(*_); end
  def symbols; end
  def uniq!(*_); end
  def unshift(*_); end
end

class Mime::NullType
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def nil?; end
  def ref; end

  private

  def method_missing(method, *args); end
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end

  class << self
    def instance; end
  end
end

Mime::PDF = T.let(T.unsafe(nil), Mime::Type)

Mime::PNG = T.let(T.unsafe(nil), Mime::Type)

Mime::RSS = T.let(T.unsafe(nil), Mime::Type)

Mime::SET = T.let(T.unsafe(nil), Mime::Mimes)

Mime::TEXT = T.let(T.unsafe(nil), Mime::Type)

Mime::TIFF = T.let(T.unsafe(nil), Mime::Type)

class Mime::Type
  def initialize(string, symbol = T.unsafe(nil), synonyms = T.unsafe(nil)); end

  def ==(mime_type); end
  def ===(list); end
  def =~(mime_type); end
  def html?; end
  def html_types; end
  def ref; end
  def symbol; end
  def to_s; end
  def to_str; end
  def to_sym; end

  private

  def method_missing(method, *args); end
  def respond_to_missing?(method, include_private = T.unsafe(nil)); end
  def to_a; end
  def to_ary; end

  class << self
    def html_types; end
    def lookup(string); end
    def lookup_by_extension(extension); end
    def parse(accept_header); end
    def parse_data_with_trailing_star(input); end
    def parse_trailing_star(accept_header); end
    def register(string, symbol, mime_type_synonyms = T.unsafe(nil), extension_synonyms = T.unsafe(nil), skip_lookup = T.unsafe(nil)); end
    def register_alias(string, symbol, extension_synonyms = T.unsafe(nil)); end
    def register_callback(&block); end
    def unregister(symbol); end
  end
end

class Mime::Type::AcceptItem
  def initialize(index, name, q = T.unsafe(nil)); end

  def <=>(item); end
  def ==(item); end
  def index; end
  def index=(_); end
  def name; end
  def name=(_); end
  def q; end
  def q=(_); end
  def to_s; end
end

class Mime::Type::AcceptList < ::Array
  def assort!; end

  private

  def app_xml; end
  def app_xml_idx; end
  def exchange_xml_items; end
  def text_xml; end
  def text_xml_idx; end
end

Mime::URL_ENCODED_FORM = T.let(T.unsafe(nil), Mime::Type)

Mime::VCF = T.let(T.unsafe(nil), Mime::Type)

Mime::XML = T.let(T.unsafe(nil), Mime::Type)

Mime::YAML = T.let(T.unsafe(nil), Mime::Type)

Mime::ZIP = T.let(T.unsafe(nil), Mime::Type)

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::VERSION = T.let(T.unsafe(nil), Array)

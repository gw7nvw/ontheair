# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `resque` gem.
# Please instead update this file by running `tapioca generate`.

# typed: true

module Resque
  include(::Resque::Helpers)
  extend(::Resque::Helpers)
  extend(::Resque)
  extend(::Forwardable)
  extend(::Resque::Scheduler::SchedulingExtensions)
  extend(::Resque::Scheduler::DelayingExtensions)
  extend(::Resque::Scheduler::Extension)

  def after_fork(&block); end
  def after_fork=(block); end
  def after_pause(&block); end
  def after_pause=(block); end
  def before_first_fork(&block); end
  def before_first_fork=(block); end
  def before_fork(&block); end
  def before_fork=(block); end
  def before_pause(&block); end
  def before_pause=(block); end
  def classify(dashed_word); end
  def constantize(camel_cased_word); end
  def data_store; end
  def decode(object); end
  def dequeue(klass, *args); end
  def encode(object); end
  def enqueue(klass, *args); end
  def enqueue_front; end
  def enqueue_front=(_); end
  def enqueue_to(queue, klass, *args); end
  def heartbeat_interval; end
  def heartbeat_interval=(_); end
  def info; end
  def inline; end
  def inline=(_); end
  def inline?; end
  def keys; end
  def list_range(key, start = T.unsafe(nil), count = T.unsafe(nil)); end
  def logger; end
  def logger=(_); end
  def peek(queue, start = T.unsafe(nil), count = T.unsafe(nil)); end
  def pop(queue); end
  def prune_interval; end
  def prune_interval=(_); end
  def push(queue, item); end
  def queue_empty(&block); end
  def queue_empty=(block); end
  def queue_from_class(klass); end
  def queue_sizes; end
  def queues; end
  def redis; end
  def redis=(server); end
  def redis_id; end
  def remove_queue(queue); end
  def remove_worker(worker_id); end
  def reserve(queue); end
  def sample_queues(sample_size = T.unsafe(nil)); end
  def size(queue); end
  def stat_data_store; end
  def stat_data_store=(stat_data_store); end
  def to_s; end
  def validate(klass, queue = T.unsafe(nil)); end
  def watch_queue(queue); end
  def worker_exit(&block); end
  def worker_exit=(block); end
  def workers; end
  def working; end

  private

  def clear_hooks(name); end
  def hooks(name); end
  def register_hook(name, block); end
end

Resque::DEFAULT_HEARTBEAT_INTERVAL = T.let(T.unsafe(nil), Fixnum)

Resque::DEFAULT_PRUNE_INTERVAL = T.let(T.unsafe(nil), Fixnum)

class Resque::DataStore
  extend(::Forwardable)

  def initialize(redis); end

  def acquire_pruning_dead_worker_lock(*args, &block); end
  def add_failed_queue(*args, &block); end
  def all_heartbeats(*args, &block); end
  def all_resque_keys; end
  def clear_failed_queue(*args, &block); end
  def clear_stat(*args, &block); end
  def decrement_stat(*args, &block); end
  def decremet_stat(*args); end
  def everything_in_queue(*args, &block); end
  def failed_queue_names(*args, &block); end
  def get_worker_payload(*args, &block); end
  def heartbeat(*args, &block); end
  def heartbeat!(*args, &block); end
  def identifier; end
  def increment_stat(*args, &block); end
  def list_range(*args, &block); end
  def method_missing(sym, *args, &block); end
  def num_failed(*args, &block); end
  def peek_in_queue(*args, &block); end
  def pop_from_queue(*args, &block); end
  def push_to_failed_queue(*args, &block); end
  def push_to_queue(*args, &block); end
  def queue_names(*args, &block); end
  def queue_size(*args, &block); end
  def reconnect; end
  def register_worker(*args, &block); end
  def remove_failed_queue(*args, &block); end
  def remove_from_failed_queue(*args, &block); end
  def remove_from_queue(*args, &block); end
  def remove_heartbeat(*args, &block); end
  def remove_queue(*args, &block); end
  def respond_to?(method, include_all = T.unsafe(nil)); end
  def server_time; end
  def set_worker_payload(*args, &block); end
  def stat(*args, &block); end
  def unregister_worker(*args, &block); end
  def update_item_in_failed_queue(*args, &block); end
  def watch_queue(*args, &block); end
  def worker_done_working(*args, &block); end
  def worker_exists?(*args, &block); end
  def worker_ids(*args, &block); end
  def worker_start_time(*args, &block); end
  def worker_started(*args, &block); end
  def workers_map(*args, &block); end
end

class Resque::DataStore::FailedQueueAccess
  def initialize(redis); end

  def add_failed_queue(failed_queue_name); end
  def clear_failed_queue(failed_queue_name = T.unsafe(nil)); end
  def failed_queue_names(find_queue_names_in_key = T.unsafe(nil)); end
  def num_failed(failed_queue_name = T.unsafe(nil)); end
  def push_to_failed_queue(data, failed_queue_name = T.unsafe(nil)); end
  def remove_failed_queue(failed_queue_name = T.unsafe(nil)); end
  def remove_from_failed_queue(index_in_failed_queue, failed_queue_name = T.unsafe(nil)); end
  def update_item_in_failed_queue(index_in_failed_queue, new_item_data, failed_queue_name = T.unsafe(nil)); end
end

Resque::DataStore::HEARTBEAT_KEY = T.let(T.unsafe(nil), String)

class Resque::DataStore::QueueAccess
  def initialize(redis); end

  def everything_in_queue(queue); end
  def list_range(key, start = T.unsafe(nil), count = T.unsafe(nil)); end
  def peek_in_queue(queue, start = T.unsafe(nil), count = T.unsafe(nil)); end
  def pop_from_queue(queue); end
  def push_to_queue(queue, encoded_item); end
  def queue_names; end
  def queue_size(queue); end
  def remove_from_queue(queue, data); end
  def remove_queue(queue); end
  def watch_queue(queue, redis: T.unsafe(nil)); end

  private

  def redis_key_for_queue(queue); end
end

class Resque::DataStore::StatsAccess
  def initialize(redis); end

  def clear_stat(stat, redis: T.unsafe(nil)); end
  def decremet_stat(stat, by = T.unsafe(nil)); end
  def increment_stat(stat, by = T.unsafe(nil), redis: T.unsafe(nil)); end
  def stat(stat); end
end

class Resque::DataStore::Workers
  def initialize(redis); end

  def acquire_pruning_dead_worker_lock(worker, expiry); end
  def all_heartbeats; end
  def get_worker_payload(worker_id); end
  def heartbeat(worker); end
  def heartbeat!(worker, time); end
  def register_worker(worker); end
  def remove_heartbeat(worker); end
  def set_worker_payload(worker, data); end
  def unregister_worker(worker, &block); end
  def worker_done_working(worker, &block); end
  def worker_exists?(worker_id); end
  def worker_ids; end
  def worker_start_time(worker); end
  def worker_started(worker, redis: T.unsafe(nil)); end
  def workers_map(worker_ids); end

  private

  def redis_key_for_worker(worker); end
  def redis_key_for_worker_pruning; end
  def redis_key_for_worker_start_time(worker); end
end

class Resque::DirtyExit < ::RuntimeError
  def initialize(message = T.unsafe(nil), process_status = T.unsafe(nil)); end

  def process_status; end
end

module Resque::Failure
  class << self
    def all(offset = T.unsafe(nil), limit = T.unsafe(nil), queue = T.unsafe(nil)); end
    def backend; end
    def backend=(backend); end
    def clear(queue = T.unsafe(nil)); end
    def clear_retried; end
    def count(queue = T.unsafe(nil), class_name = T.unsafe(nil)); end
    def create(options = T.unsafe(nil)); end
    def each(offset = T.unsafe(nil), limit = T.unsafe(nil), queue = T.unsafe(nil), class_name = T.unsafe(nil), order = T.unsafe(nil), &block); end
    def failure_queue_name(job_queue_name); end
    def job_queue_name(failure_queue_name); end
    def queues; end
    def remove(id, queue = T.unsafe(nil)); end
    def remove_queue(queue); end
    def requeue(id, queue = T.unsafe(nil)); end
    def requeue_all; end
    def requeue_queue(queue); end
    def url; end
  end
end

class Resque::Failure::Base
  def initialize(exception, worker, queue, payload); end

  def exception; end
  def exception=(_); end
  def log(message); end
  def payload; end
  def payload=(_); end
  def queue; end
  def queue=(_); end
  def save; end
  def worker; end
  def worker=(_); end

  class << self
    def all(offset = T.unsafe(nil), limit = T.unsafe(nil), queue = T.unsafe(nil)); end
    def clear(*args); end
    def count(queue = T.unsafe(nil), class_name = T.unsafe(nil)); end
    def each(*args); end
    def queues; end
    def remove(*args); end
    def requeue(*args); end
    def url; end
  end
end

module Resque::Helpers
  def classify(dashed_word); end
  def constantize(camel_cased_word); end
  def decode(object); end
  def encode(object); end
  def redis; end
end

class Resque::Helpers::DecodeException < ::StandardError
end

class Resque::Job
  include(::Resque::Helpers)
  extend(::Resque::Helpers)

  def initialize(queue, payload); end

  def ==(other); end
  def after_hooks; end
  def args; end
  def around_hooks; end
  def before_hooks; end
  def classify(dashed_word); end
  def constantize(camel_cased_word); end
  def data_store; end
  def decode(object); end
  def encode(object); end
  def fail(exception); end
  def failure_hooks; end
  def has_payload_class?; end
  def inspect; end
  def payload; end
  def payload_class; end
  def payload_class_name; end
  def perform; end
  def queue; end
  def recreate; end
  def redis; end
  def run_failure_hooks(exception); end
  def worker; end
  def worker=(_); end

  class << self
    def create(queue, klass, *args); end
    def data_store; end
    def decode(object); end
    def destroy(queue, klass, *args); end
    def encode(object); end
    def redis; end
    def reserve(queue); end
  end
end

class Resque::Job::DontPerform < ::StandardError
end

module Resque::Logging

  private

  def debug(message); end
  def error(message); end
  def fatal(message); end
  def info(message); end
  def warn(message); end

  class << self
    def debug(message); end
    def error(message); end
    def fatal(message); end
    def info(message); end
    def log(severity, message); end
    def warn(message); end
  end
end

class Resque::NoClassError < ::RuntimeError
end

class Resque::NoQueueError < ::RuntimeError
end

module Resque::Plugin
  extend(::Resque::Plugin)

  def after_dequeue_hooks(job); end
  def after_enqueue_hooks(job); end
  def after_hooks(job); end
  def around_hooks(job); end
  def before_dequeue_hooks(job); end
  def before_enqueue_hooks(job); end
  def before_hooks(job); end
  def failure_hooks(job); end
  def get_hook_names(job, hook_method_prefix); end
  def job_methods(job); end
  def lint(plugin); end
end

class Resque::Plugin::LintError < ::RuntimeError
end

class Resque::PruneDeadWorkerDirtyExit < ::Resque::DirtyExit
  def initialize(hostname, job); end
end

class Resque::QuietFormatter
  def call(serverity, datetime, progname, msg); end
end

class Resque::Railtie < ::Rails::Railtie
end

module Resque::Stat
  extend(::Resque::Stat)

  def <<(stat); end
  def >>(stat); end
  def [](stat); end
  def clear(stat, **opts); end
  def data_store; end
  def data_store=(data_store); end
  def decr(stat, by = T.unsafe(nil)); end
  def get(stat); end
  def incr(stat, by = T.unsafe(nil), **opts); end
  def redis; end
end

class Resque::TermException < ::SignalException
end

class Resque::ThreadSignal
  def initialize; end

  def signal; end
  def wait_for_signal(timeout); end
end

Resque::VERSION = T.let(T.unsafe(nil), String)

class Resque::VerboseFormatter
  def call(serverity, datetime, progname, msg); end
end

class Resque::VeryVerboseFormatter
  def call(serverity, datetime, progname, msg); end
end

class Resque::Worker
  include(::Resque::Helpers)
  include(::Resque::Logging)
  extend(::Resque::Helpers)

  def initialize(*queues); end

  def ==(other); end
  def child_already_exited?; end
  def data_store; end
  def decode(object); end
  def done_working; end
  def enable_gc_optimizations; end
  def encode(object); end
  def failed; end
  def failed!; end
  def fork_per_job=(_); end
  def fork_per_job?; end
  def glob_match(list, pattern); end
  def graceful_term; end
  def graceful_term=(_); end
  def heartbeat; end
  def heartbeat!(time = T.unsafe(nil)); end
  def hostname; end
  def hostname=(_); end
  def id; end
  def idle?; end
  def inspect; end
  def job(reload = T.unsafe(nil)); end
  def job=(_); end
  def kill_background_threads; end
  def kill_child; end
  def linux_worker_pids; end
  def log(message); end
  def log!(message); end
  def new_kill_child; end
  def pause_processing; end
  def paused?; end
  def perform(job); end
  def pid; end
  def pid=(_); end
  def pre_shutdown_timeout; end
  def pre_shutdown_timeout=(_); end
  def prepare; end
  def process(job = T.unsafe(nil), &block); end
  def processed; end
  def processed!(**opts); end
  def processing(reload = T.unsafe(nil)); end
  def procline(string); end
  def prune_dead_workers; end
  def queues; end
  def queues=(queues); end
  def reconnect; end
  def redis; end
  def register_signal_handlers; end
  def register_worker; end
  def remove_heartbeat; end
  def report_failed_job(job, exception); end
  def reserve; end
  def run_at_exit_hooks; end
  def run_at_exit_hooks=(_); end
  def run_hook(name, *args); end
  def shutdown; end
  def shutdown!; end
  def shutdown?; end
  def solaris_worker_pids; end
  def start_heartbeat; end
  def started; end
  def started!; end
  def startup; end
  def state; end
  def state_change; end
  def term_child; end
  def term_child=(_); end
  def term_child_signal; end
  def term_child_signal=(_); end
  def term_timeout; end
  def term_timeout=(_); end
  def to_s; end
  def to_s=(_); end
  def unpause_processing; end
  def unregister_signal_handlers; end
  def unregister_worker(exception = T.unsafe(nil)); end
  def validate_queues; end
  def verbose; end
  def verbose=(value); end
  def very_verbose; end
  def very_verbose=(value); end
  def wait_for_child_exit(timeout); end
  def windows_worker_pids; end
  def work(interval = T.unsafe(nil), &block); end
  def work_one_job(job = T.unsafe(nil), &block); end
  def worker_pids; end
  def working?; end
  def working_on(job); end

  private

  def log_with_severity(severity, message); end
  def perform_with_fork(job, &block); end

  class << self
    def all; end
    def all_heartbeats; end
    def all_workers_with_expired_heartbeats; end
    def attach(worker_id); end
    def data_store; end
    def exists?(worker_id); end
    def find(worker_id, options = T.unsafe(nil)); end
    def kill_all_heartbeat_threads; end
    def redis; end
    def working; end
  end
end

Resque::Worker::WILDCARDS = T.let(T.unsafe(nil), Array)

module UTF8Util
  class << self
    def clean(str); end
    def clean!(str); end
  end
end

UTF8Util::REPLACEMENT_CHAR = T.let(T.unsafe(nil), String)
